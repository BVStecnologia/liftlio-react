<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liftlio - 5 Estilos de Neur√¥nios Sociais</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0a0a0a;
            color: white;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: relative;
            z-index: 100;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
        }
        
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .style-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background: rgba(0,0,0,0.8);
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            flex-wrap: wrap;
        }
        
        .style-btn {
            padding: 15px 30px;
            border: 2px solid;
            background: transparent;
            color: white;
            cursor: pointer;
            border-radius: 50px;
            font-size: 16px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .style-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .style-btn:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .style-btn.active {
            background: rgba(255,255,255,0.1);
            transform: scale(1.05);
            box-shadow: 0 0 30px currentColor;
        }
        
        #style1 { border-color: #ff00ff; color: #ff00ff; }
        #style2 { border-color: #00ffff; color: #00ffff; }
        #style3 { border-color: #ffff00; color: #ffff00; }
        #style4 { border-color: #ff6b00; color: #ff6b00; }
        #style5 { border-color: #00ff00; color: #00ff00; }
        
        .canvas-container {
            width: 100%;
            height: 600px;
            position: relative;
            background: #000;
        }
        
        canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        .style-name {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #fff;
        }
        
        .style-description {
            opacity: 0.8;
            line-height: 1.4;
        }
        
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
        }
        
        .stat-value {
            font-weight: bold;
            color: #667eea;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }
        
        .control-btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            background: #764ba2;
            transform: scale(1.1);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        .particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üß† Neur√¥nios Sociais - Liftlio</h1>
        <p class="subtitle">Visualiza√ß√£o do Poder do Boca a Boca com IA</p>
    </div>
    
    <div class="style-selector">
        <button class="style-btn active" id="style1" onclick="changeStyle(1)">
            üåÉ Cyberpunk Matrix
        </button>
        <button class="style-btn" id="style2" onclick="changeStyle(2)">
            üåä Ocean Mind
        </button>
        <button class="style-btn" id="style3" onclick="changeStyle(3)">
            ‚öõÔ∏è Quantum Field
        </button>
        <button class="style-btn" id="style4" onclick="changeStyle(4)">
            ‚ú® Cosmic Synaptic
        </button>
        <button class="style-btn" id="style5" onclick="changeStyle(5)">
            üíé Crystal Lattice
        </button>
    </div>
    
    <div class="canvas-container">
        <div class="loading">Carregando neur√¥nios...</div>
        <canvas id="neural-canvas"></canvas>
        
        <div class="info-panel">
            <h2 class="style-name" id="style-name">Cyberpunk Neural Matrix</h2>
            <p class="style-description" id="style-description">
                Neur√¥nios em neon roxo/rosa com sinapses el√©tricas. 
                Efeito Matrix quando viraliza. Glitch effects representam crescimento explosivo.
            </p>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <span>Neur√¥nios Ativos</span>
                <span class="stat-value" id="neuron-count">0</span>
            </div>
            <div class="stat-item">
                <span>Conex√µes</span>
                <span class="stat-value" id="connection-count">0</span>
            </div>
            <div class="stat-item">
                <span>Taxa Viral</span>
                <span class="stat-value" id="viral-rate">0%</span>
            </div>
            <div class="stat-item">
                <span>Alcance Total</span>
                <span class="stat-value" id="reach">0</span>
            </div>
        </div>
        
        <div class="controls">
            <button class="control-btn" onclick="triggerRecommendation()">
                üöÄ Simular Recomenda√ß√£o
            </button>
            <button class="control-btn" onclick="triggerViral()">
                üî• Modo Viral
            </button>
            <button class="control-btn" onclick="resetNetwork()">
                üîÑ Resetar
            </button>
        </div>
    </div>
    
    <script>
        let scene, camera, renderer;
        let neurons = [];
        let connections = [];
        let particles = [];
        let currentStyle = 1;
        let animationId;
        let neuronCount = 5;
        let connectionCount = 0;
        let viralRate = 0;
        let reach = 5;
        
        const styles = {
            1: {
                name: "Cyberpunk Neural Matrix",
                description: "Neur√¥nios em neon roxo/rosa com sinapses el√©tricas. Efeito Matrix quando viraliza.",
                colors: { 
                    primary: 0xff00ff, 
                    secondary: 0x00ffff, 
                    background: 0x0a0014,
                    pulse: 0xff00aa
                },
                particleCount: 500,
                speed: 0.02
            },
            2: {
                name: "Bioluminescent Ocean Mind",
                description: "Neur√¥nios como √°guas-vivas bioluminescentes em oceano digital profundo.",
                colors: { 
                    primary: 0x00ffff, 
                    secondary: 0x00ff88, 
                    background: 0x001122,
                    pulse: 0x00ffcc
                },
                particleCount: 300,
                speed: 0.01
            },
            3: {
                name: "Quantum Consciousness Field",
                description: "Neur√¥nios em superposi√ß√£o qu√¢ntica com entrela√ßamento instant√¢neo.",
                colors: { 
                    primary: 0xffff00, 
                    secondary: 0xffffff, 
                    background: 0x000033,
                    pulse: 0xffffaa
                },
                particleCount: 1000,
                speed: 0.03
            },
            4: {
                name: "Cosmic Synaptic Constellation",
                description: "Neur√¥nios como estrelas em nebulosa com auroras conectando sistemas.",
                colors: { 
                    primary: 0xff6600, 
                    secondary: 0xffaa00, 
                    background: 0x000011,
                    pulse: 0xff9900
                },
                particleCount: 400,
                speed: 0.015
            },
            5: {
                name: "Crystal Neural Lattice",
                description: "Neur√¥nios cristalinos que refratam luz em arco-√≠ris com resson√¢ncia harm√¥nica.",
                colors: { 
                    primary: 0x00ff00, 
                    secondary: 0xffffff, 
                    background: 0x001100,
                    pulse: 0x00ff55
                },
                particleCount: 200,
                speed: 0.025
            }
        };
        
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(styles[currentStyle].colors.background, 10, 50);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / 600, 0.1, 1000);
            camera.position.z = 30;
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('neural-canvas'),
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, 600);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Luz ambiente
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            // Luz pontual
            const pointLight = new THREE.PointLight(styles[currentStyle].colors.primary, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            createNeurons();
            createConnections();
            createParticles();
            
            document.querySelector('.loading').style.display = 'none';
            animate();
            updateStats();
        }
        
        function createNeurons() {
            const style = styles[currentStyle];
            
            for (let i = 0; i < neuronCount; i++) {
                const geometry = currentStyle === 5 ? 
                    new THREE.OctahedronGeometry(1.5, 0) : 
                    new THREE.SphereGeometry(1.5, 32, 32);
                    
                const material = new THREE.MeshPhongMaterial({
                    color: style.colors.primary,
                    emissive: style.colors.pulse,
                    emissiveIntensity: 0.5,
                    wireframe: currentStyle === 1,
                    transparent: true,
                    opacity: currentStyle === 2 ? 0.7 : 0.9
                });
                
                const neuron = new THREE.Mesh(geometry, material);
                neuron.position.x = (Math.random() - 0.5) * 40;
                neuron.position.y = (Math.random() - 0.5) * 20;
                neuron.position.z = (Math.random() - 0.5) * 20;
                
                neuron.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1
                    ),
                    pulsePhase: Math.random() * Math.PI * 2
                };
                
                neurons.push(neuron);
                scene.add(neuron);
            }
        }
        
        function createConnections() {
            const style = styles[currentStyle];
            
            for (let i = 0; i < neurons.length; i++) {
                for (let j = i + 1; j < neurons.length; j++) {
                    if (Math.random() > 0.6) {
                        const points = [neurons[i].position, neurons[j].position];
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        
                        const material = new THREE.LineBasicMaterial({
                            color: style.colors.secondary,
                            transparent: true,
                            opacity: 0.3
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        line.userData = { 
                            from: neurons[i], 
                            to: neurons[j],
                            pulseTime: 0
                        };
                        
                        connections.push(line);
                        scene.add(line);
                        connectionCount++;
                    }
                }
            }
        }
        
        function createParticles() {
            const style = styles[currentStyle];
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = style.particleCount;
            
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 50;
                positions[i + 1] = (Math.random() - 0.5) * 30;
                positions[i + 2] = (Math.random() - 0.5) * 30;
                
                const color = new THREE.Color(style.colors.secondary);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });
            
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            particles.push(particleSystem);
            scene.add(particleSystem);
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            const style = styles[currentStyle];
            const time = Date.now() * 0.001;
            
            // Animar neur√¥nios
            neurons.forEach((neuron, index) => {
                // Movimento flutuante
                neuron.position.x += neuron.userData.velocity.x;
                neuron.position.y += neuron.userData.velocity.y;
                neuron.position.z += neuron.userData.velocity.z;
                
                // Limites
                ['x', 'y', 'z'].forEach(axis => {
                    if (Math.abs(neuron.position[axis]) > 20) {
                        neuron.userData.velocity[axis] *= -1;
                    }
                });
                
                // Pulsa√ß√£o
                const pulse = Math.sin(time * 2 + neuron.userData.pulsePhase) * 0.2 + 1;
                neuron.scale.set(pulse, pulse, pulse);
                
                // Rota√ß√£o para cristais
                if (currentStyle === 5) {
                    neuron.rotation.x += 0.01;
                    neuron.rotation.y += 0.01;
                }
            });
            
            // Animar conex√µes
            connections.forEach(connection => {
                const points = [
                    connection.userData.from.position,
                    connection.userData.to.position
                ];
                connection.geometry.setFromPoints(points);
                
                // Pulso nas conex√µes
                connection.userData.pulseTime += 0.05;
                const pulse = Math.sin(connection.userData.pulseTime) * 0.5 + 0.5;
                connection.material.opacity = 0.1 + pulse * 0.4;
            });
            
            // Animar part√≠culas
            particles.forEach(particleSystem => {
                particleSystem.rotation.y += style.speed * 0.1;
                
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += Math.sin(time + i) * 0.01;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
            });
            
            // Movimento da c√¢mera
            camera.position.x = Math.sin(time * 0.1) * 5;
            camera.position.y = Math.cos(time * 0.1) * 3;
            camera.lookAt(scene.position);
            
            renderer.render(scene, camera);
        }
        
        function changeStyle(styleNumber) {
            currentStyle = styleNumber;
            
            // Atualizar bot√µes
            document.querySelectorAll('.style-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`style${styleNumber}`).classList.add('active');
            
            // Atualizar informa√ß√µes
            const style = styles[styleNumber];
            document.getElementById('style-name').textContent = style.name;
            document.getElementById('style-description').textContent = style.description;
            
            // Limpar cena
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            neurons = [];
            connections = [];
            particles = [];
            connectionCount = 0;
            
            // Recriar com novo estilo
            scene.fog = new THREE.Fog(style.colors.background, 10, 50);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(style.colors.primary, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            createNeurons();
            createConnections();
            createParticles();
            updateStats();
        }
        
        function triggerRecommendation() {
            // Adicionar novo neur√¥nio
            const style = styles[currentStyle];
            
            const geometry = currentStyle === 5 ? 
                new THREE.OctahedronGeometry(2, 0) : 
                new THREE.SphereGeometry(2, 32, 32);
                
            const material = new THREE.MeshPhongMaterial({
                color: style.colors.pulse,
                emissive: style.colors.primary,
                emissiveIntensity: 0.8,
                wireframe: currentStyle === 1,
                transparent: true,
                opacity: 1
            });
            
            const newNeuron = new THREE.Mesh(geometry, material);
            newNeuron.position.x = (Math.random() - 0.5) * 30;
            newNeuron.position.y = (Math.random() - 0.5) * 15;
            newNeuron.position.z = (Math.random() - 0.5) * 15;
            
            newNeuron.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                ),
                pulsePhase: Math.random() * Math.PI * 2
            };
            
            neurons.push(newNeuron);
            scene.add(newNeuron);
            neuronCount++;
            
            // Criar conex√µes com neur√¥nios existentes
            for (let i = 0; i < neurons.length - 1; i++) {
                if (Math.random() > 0.5) {
                    const points = [neurons[i].position, newNeuron.position];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    const material = new THREE.LineBasicMaterial({
                        color: style.colors.primary,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.userData = { 
                        from: neurons[i], 
                        to: newNeuron,
                        pulseTime: 0
                    };
                    
                    connections.push(line);
                    scene.add(line);
                    connectionCount++;
                }
            }
            
            reach = Math.floor(neuronCount * (1 + Math.random() * 2));
            viralRate = Math.min(100, viralRate + Math.random() * 10);
            updateStats();
        }
        
        function triggerViral() {
            // Criar explos√£o de neur√¥nios
            for (let i = 0; i < 10; i++) {
                setTimeout(() => triggerRecommendation(), i * 200);
            }
            
            // Efeito visual especial
            const style = styles[currentStyle];
            scene.fog.color.setHex(style.colors.pulse);
            setTimeout(() => {
                scene.fog.color.setHex(style.colors.background);
            }, 2000);
            
            viralRate = 100;
            updateStats();
        }
        
        function resetNetwork() {
            // Limpar tudo exceto neur√¥nios iniciais
            while (neurons.length > 5) {
                scene.remove(neurons.pop());
            }
            
            connections.forEach(conn => scene.remove(conn));
            connections = [];
            
            neuronCount = 5;
            connectionCount = 0;
            viralRate = 0;
            reach = 5;
            
            createConnections();
            updateStats();
        }
        
        function updateStats() {
            document.getElementById('neuron-count').textContent = neuronCount;
            document.getElementById('connection-count').textContent = connectionCount;
            document.getElementById('viral-rate').textContent = Math.floor(viralRate) + '%';
            document.getElementById('reach').textContent = reach.toLocaleString();
        }
        
        // Responsividade
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / 600;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, 600);
        });
        
        // Inicializar
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>