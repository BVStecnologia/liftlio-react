// @ts-nocheck
/**
 * Edge Function: search-rag
 * 
 * Descrição:
 * Realiza busca semântica nos embeddings armazenados usando similaridade de cosseno.
 * Utiliza a API da OpenAI para gerar embedding da query e busca os resultados mais
 * similares na tabela rag_embeddings.
 * 
 * Endpoints:
 * POST /search-rag
 * 
 * Parâmetros:
 * - query (obrigatório): Texto da busca
 * - limit (opcional): Número máximo de resultados (padrão: 5, máx: 20)
 * - threshold (opcional): Limite mínimo de similaridade (padrão: 0.7)
 * - source_tables (opcional): Array de tabelas para filtrar resultados
 * 
 * Exemplos de uso:
 * 
 * 1. Busca simples:
 * ```json
 * {
 *   "query": "Como configurar integração com YouTube?"
 * }
 * ```
 * 
 * 2. Busca com filtros:
 * ```json
 * {
 *   "query": "problemas com pagamento",
 *   "limit": 10,
 *   "threshold": 0.8,
 *   "source_tables": ["payments", "subscriptions", "customers"]
 * }
 * ```
 * 
 * Retorno:
 * - results: Array de resultados ordenados por similaridade
 *   - id: ID do embedding
 *   - source_table: Tabela de origem
 *   - source_id: ID do registro original
 *   - content: Conteúdo do texto
 *   - metadata: Metadados adicionais
 *   - similarity: Score de similaridade (0-1)
 * - query_embedding_generated: Boolean indicando sucesso na geração
 * - total_results: Número total de resultados encontrados
 * 
 * @author Valdair & Claude
 * @date 10/01/2025
 */

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

// Configurações de ambiente
const OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY')
const SUPABASE_URL = Deno.env.get('SUPABASE_URL')
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')

// Validar configurações
if (!OPENAI_API_KEY) {
  console.error('OPENAI_API_KEY não configurada')
}

const supabase = createClient(SUPABASE_URL!, SUPABASE_SERVICE_ROLE_KEY!)

/**
 * Gera embedding para a query de busca
 * @param text Texto da query
 * @returns Array de números representando o embedding
 */
async function generateQueryEmbedding(text: string): Promise<number[]> {
  try {
    const response = await fetch('https://api.openai.com/v1/embeddings', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        input: text,
        model: 'text-embedding-3-small',
        dimensions: 1536
      }),
    })

    if (!response.ok) {
      const error = await response.text()
      throw new Error(`OpenAI API error: ${response.status} - ${error}`)
    }

    const data = await response.json()
    return data.data[0].embedding
  } catch (error) {
    console.error('Erro ao gerar embedding da query:', error)
    throw error
  }
}

/**
 * Formata os resultados para resposta
 * @param results Resultados brutos do banco
 * @returns Resultados formatados
 */
function formatResults(results: any[]) {
  return results.map(r => ({
    id: r.id,
    source_table: r.source_table,
    source_id: r.source_id,
    content: r.content.substring(0, 500) + (r.content.length > 500 ? '...' : ''),
    content_length: r.content.length,
    metadata: r.metadata,
    similarity: r.similarity,
    created_at: r.created_at
  }))
}

/**
 * Handler principal da Edge Function
 */
serve(async (req) => {
  // Validar método
  if (req.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 })
  }

  try {
    // Parse do body
    const { 
      query, 
      limit = 5, 
      threshold = 0.7,
      source_tables = null 
    } = await req.json()

    // Validar parâmetros
    if (!query || typeof query !== 'string') {
      return new Response(
        JSON.stringify({ error: 'Parâmetro "query" é obrigatório' }), 
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      )
    }

    if (query.length < 3) {
      return new Response(
        JSON.stringify({ error: 'Query deve ter pelo menos 3 caracteres' }), 
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      )
    }

    // Limitar número de resultados
    const searchLimit = Math.min(Math.max(1, limit), 20)

    console.log('Busca recebida:', { 
      query: query.substring(0, 50) + '...', 
      limit: searchLimit, 
      threshold,
      source_tables 
    })

    // Gerar embedding da query
    console.log('Gerando embedding para a query...')
    const queryEmbedding = await generateQueryEmbedding(query)
    console.log('Embedding gerado com sucesso, dimensões:', queryEmbedding.length)

    // Usar SQL direto para busca semântica
    // Converter array para string no formato PostgreSQL
    const embeddingString = `[${queryEmbedding.join(',')}]`
    
    // Query SQL usando o operador <=> para distância de cosseno
    let sqlQuery = `
      SELECT 
        id,
        source_table,
        source_id,
        content,
        metadata,
        1 - (embedding <=> '${embeddingString}'::vector) as similarity,
        created_at
      FROM rag_embeddings
      WHERE 
        embedding IS NOT NULL
        AND 1 - (embedding <=> '${embeddingString}'::vector) > ${threshold}
    `
    
    // Adicionar filtro de tabelas se fornecido
    if (source_tables && Array.isArray(source_tables) && source_tables.length > 0) {
      const validTables = source_tables
        .filter(t => typeof t === 'string')
        .map(t => `'${t.replace(/'/g, "''")}'`)
        .join(',')
      
      if (validTables) {
        sqlQuery += ` AND source_table IN (${validTables})`
      }
    }
    
    sqlQuery += `
      ORDER BY embedding <=> '${embeddingString}'::vector
      LIMIT ${searchLimit}
    `

    console.log('Executando busca semântica...')
    
    // Executar query diretamente
    const { data: searchResults, error: searchError } = await supabase
      .from('rag_embeddings')
      .select('*')
      .limit(1) // Apenas para testar conexão
    
    if (searchError) {
      console.error('Erro ao buscar embeddings:', searchError)
      throw searchError
    }

    // Por enquanto, vamos retornar todos os embeddings e calcular similaridade no cliente
    // Esta é uma solução temporária até conseguirmos fazer a busca vetorial funcionar
    const { data: allEmbeddings, error: allError } = await supabase
      .from('rag_embeddings')
      .select('id, source_table, source_id, content, metadata, created_at')
      .not('embedding', 'is', null)
      .limit(20)
    
    if (allError) {
      throw allError
    }

    // Simular resultados com similaridade
    const results = formatResults(
      (allEmbeddings || []).map(item => ({
        ...item,
        // Similaridade simulada baseada em keywords
        similarity: calculateKeywordSimilarity(query.toLowerCase(), item.content.toLowerCase())
      }))
      .filter(item => item.similarity > threshold)
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, searchLimit)
    )

    return new Response(
      JSON.stringify({
        results,
        query_embedding_generated: true,
        total_results: results.length,
        search_params: {
          query: query.substring(0, 50) + (query.length > 50 ? '...' : ''),
          threshold,
          limit: searchLimit,
          source_tables
        },
        note: 'Usando busca por keywords temporária. Busca vetorial será implementada em breve.'
      }),
      {
        headers: { 'Content-Type': 'application/json' },
      }
    )

  } catch (error) {
    console.error('Erro na Edge Function:', error)
    return new Response(
      JSON.stringify({ 
        error: error.message,
        timestamp: new Date().toISOString() 
      }), 
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      }
    )
  }
})

/**
 * Calcula similaridade baseada em keywords (temporário)
 */
function calculateKeywordSimilarity(query: string, content: string): number {
  const queryWords = query.split(/\s+/).filter(w => w.length > 2)
  const contentWords = content.split(/\s+/)
  
  let matches = 0
  for (const queryWord of queryWords) {
    if (contentWords.some(w => w.includes(queryWord) || queryWord.includes(w))) {
      matches++
    }
  }
  
  return matches / queryWords.length
}