// @ts-nocheck
/**
 * Edge Function: process-rag-embeddings
 * 
 * Descrição:
 * Processa registros de várias tabelas do Liftlio para gerar embeddings usando
 * a API da OpenAI (modelo text-embedding-3-small). Os embeddings são armazenados
 * na tabela rag_embeddings para busca semântica posterior.
 * 
 * Endpoints:
 * POST /process-rag-embeddings
 * 
 * Parâmetros:
 * - table (opcional): Nome da tabela específica para processar
 * - limit (opcional): Número máximo de registros por batch (padrão: 50)
 * 
 * Exemplos de uso:
 * 
 * 1. Processar uma tabela específica:
 * ```json
 * {
 *   "table": "Videos_trancricao",
 *   "limit": 20
 * }
 * ```
 * 
 * 2. Processar todas as tabelas configuradas:
 * ```json
 * {
 *   "limit": 30
 * }
 * ```
 * 
 * Retorno:
 * - processed: Número de registros processados
 * - results: Array com status de cada registro
 * 
 * @author Valdair & Claude
 * @date 10/01/2025
 */

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

// Configurações de ambiente
const OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY')
const SUPABASE_URL = Deno.env.get('SUPABASE_URL')
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')

// Validar configurações
if (!OPENAI_API_KEY) {
  console.error('OPENAI_API_KEY não configurada')
}

const supabase = createClient(SUPABASE_URL!, SUPABASE_SERVICE_ROLE_KEY!)

/**
 * Configuração de mapeamento para cada tabela
 * Define quais campos usar para conteúdo e metadata
 * Atualizado com os campos reais das tabelas
 */
const TABLE_CONFIG: Record<string, {
  contentFields: string[]
  metadataFields: string[]
  chunkSize?: number
}> = {
  'Comentarios_Principais': {
    contentFields: ['comentario'],
    metadataFields: ['video_id', 'canal_id', 'sentiment', 'autor']
  },
  'Mensagens': {
    contentFields: ['mensagem'],
    metadataFields: ['project_id', 'user_id', 'tipo', 'created_at']
  },
  'Videos': {
    // Campos reais da tabela Videos
    contentFields: ['video_title', 'video_description', 'ai_analysis_summary'],
    metadataFields: ['VIDEO', 'Channel', 'view_count', 'like_count', 'comment_count', 'relevance_score', 'sentiment_analysis']
  },
  'Videos_trancricao': {
    contentFields: ['transcricao'],
    metadataFields: ['video_id'],
    chunkSize: 1000 // Dividir transcrições longas em chunks
  },
  'Respostas_Comentarios': {
    contentFields: ['resposta'],
    metadataFields: ['comentario_id', 'autor']
  },
  'Canais do youtube': {
    contentFields: ['nome', 'descricao'],
    metadataFields: ['canal_id', 'inscritos']
  },
  'Projeto': {
    // Campos reais da tabela Projeto
    contentFields: ['Project name', 'description service', 'Keywords'],
    metadataFields: ['User id', 'status', 'País', 'integracao_valida']
  },
  'Integrações': {
    contentFields: ['nome', 'tipo', 'status'],
    metadataFields: ['project_id', 'configuracoes']
  },
  'Scanner de videos do youtube': {
    contentFields: ['query', 'status'],
    metadataFields: ['project_id', 'resultados_encontrados']
  },
  'Notificacoes': {
    contentFields: ['titulo', 'mensagem'],
    metadataFields: ['user_id', 'tipo', 'lida']
  },
  'cards': {
    contentFields: ['last4', 'brand'],
    metadataFields: ['customer_id', 'status']
  },
  'customers': {
    contentFields: ['email', 'name'],
    metadataFields: ['stripe_customer_id']
  },
  'payments': {
    contentFields: ['status', 'amount'],
    metadataFields: ['customer_id', 'created_at']
  },
  'subscriptions': {
    contentFields: ['status', 'plan_name'],
    metadataFields: ['customer_id', 'current_period_end']
  }
}

/**
 * Gera embedding usando a API da OpenAI
 * @param text Texto para gerar embedding
 * @returns Array de números representando o embedding
 */
async function generateEmbedding(text: string): Promise<number[]> {
  try {
    const response = await fetch('https://api.openai.com/v1/embeddings', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        input: text.substring(0, 8000), // Limitar a 8k tokens aprox
        model: 'text-embedding-3-small',
        dimensions: 1536 // Usar dimensões completas para melhor qualidade
      }),
    })

    if (!response.ok) {
      const error = await response.text()
      throw new Error(`OpenAI API error: ${response.status} - ${error}`)
    }

    const data = await response.json()
    return data.data[0].embedding
  } catch (error) {
    console.error('Erro ao gerar embedding:', error)
    throw error
  }
}

/**
 * Processa registros de uma tabela específica
 * @param tableName Nome da tabela para processar
 * @param limit Número máximo de registros
 * @returns Objeto com resultados do processamento
 */
async function processTable(tableName: string, limit = 50) {
  const config = TABLE_CONFIG[tableName]
  if (!config) {
    return { error: `Configuração não encontrada para tabela: ${tableName}` }
  }

  console.log(`Processando tabela: ${tableName}`)

  try {
    // Buscar registros não processados
    const { data: records, error } = await supabase
      .from(tableName)
      .select('*')
      .eq('rag_processed', false)
      .limit(limit)

    if (error) {
      console.error(`Erro ao buscar registros de ${tableName}:`, error)
      return { error: error.message }
    }

    if (!records || records.length === 0) {
      return { 
        processed: 0, 
        message: `Nenhum registro pendente em ${tableName}` 
      }
    }

    const results = []

    for (const record of records) {
      try {
        // Construir conteúdo para embedding
        const contentParts = config.contentFields
          .map(field => {
            const value = record[field]
            // Handle JSON fields like sentiment_analysis
            if (typeof value === 'object' && value !== null) {
              return JSON.stringify(value)
            }
            return value
          })
          .filter(Boolean)
        
        if (contentParts.length === 0) {
          console.warn(`Registro ${record.id} em ${tableName} não tem conteúdo`)
          continue
        }
        
        const content = contentParts.join(' ')
        
        // Gerar metadata
        const metadata: Record<string, any> = {
          source_table: tableName,
          source_record_id: record.id
        }
        
        config.metadataFields.forEach(field => {
          if (record[field] !== null && record[field] !== undefined) {
            metadata[field] = record[field]
          }
        })

        // Gerar embedding
        console.log(`Gerando embedding para ${tableName}:${record.id}`)
        const embedding = await generateEmbedding(content)

        // Salvar em rag_embeddings
        const { error: insertError } = await supabase
          .from('rag_embeddings')
          .insert({
            source_table: tableName,
            source_id: record.id.toString(),
            content: content.substring(0, 10000), // Limitar tamanho do conteúdo
            embedding,
            metadata
          })

        if (insertError) {
          throw new Error(`Erro ao inserir embedding: ${insertError.message}`)
        }

        // Marcar como processado
        const { error: updateError } = await supabase
          .from(tableName)
          .update({ 
            rag_processed: true,
            rag_processed_at: new Date().toISOString()
          })
          .eq('id', record.id)

        if (updateError) {
          throw new Error(`Erro ao atualizar registro: ${updateError.message}`)
        }

        results.push({ 
          id: record.id, 
          status: 'success',
          content_length: content.length 
        })

        // Rate limiting: aguardar 50ms entre requests para evitar rate limit
        await new Promise(resolve => setTimeout(resolve, 50))

      } catch (error) {
        console.error(`Erro ao processar registro ${record.id}:`, error)
        results.push({ 
          id: record.id, 
          status: 'error', 
          error: error.message 
        })
      }
    }

    return { 
      table: tableName,
      processed: results.filter(r => r.status === 'success').length,
      errors: results.filter(r => r.status === 'error').length,
      results 
    }

  } catch (error) {
    console.error(`Erro geral ao processar ${tableName}:`, error)
    return { 
      error: error.message,
      table: tableName 
    }
  }
}

/**
 * Handler principal da Edge Function
 */
serve(async (req) => {
  // Validar método
  if (req.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 })
  }

  try {
    // Parse do body
    const { table, limit = 50 } = await req.json()

    console.log('Requisição recebida:', { table, limit })

    // Se não especificar tabela, processar todas
    if (!table) {
      const allResults = []
      
      for (const tableName of Object.keys(TABLE_CONFIG)) {
        const result = await processTable(tableName, limit)
        allResults.push(result)
        
        // Pequena pausa entre tabelas
        await new Promise(resolve => setTimeout(resolve, 100))
      }
      
      const summary = {
        total_processed: allResults.reduce((sum, r) => sum + (r.processed || 0), 0),
        total_errors: allResults.reduce((sum, r) => sum + (r.errors || 0), 0),
        tables: allResults
      }
      
      return new Response(JSON.stringify(summary), {
        headers: { 'Content-Type': 'application/json' },
      })
    }

    // Processar tabela específica
    const result = await processTable(table, limit)
    
    return new Response(JSON.stringify(result), {
      headers: { 'Content-Type': 'application/json' },
    })

  } catch (error) {
    console.error('Erro na Edge Function:', error)
    return new Response(
      JSON.stringify({ 
        error: error.message,
        timestamp: new Date().toISOString() 
      }), 
      {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      }
    )
  }
})