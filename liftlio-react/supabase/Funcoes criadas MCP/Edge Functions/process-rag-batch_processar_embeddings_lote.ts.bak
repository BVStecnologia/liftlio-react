/**
 * process-rag-batch
 * 
 * Edge Function para processar embeddings em lote
 * Processa múltiplos registros de uma tabela específica
 * 
 * Criado via MCP em: 11/01/2025
 * 
 * @param {Object} req.body
 * @param {string} [req.body.table_name='Mensagens'] - Nome da tabela
 * @param {number} [req.body.limit=10] - Número de registros por lote
 * @param {number} [req.body.project_id=71] - ID do projeto
 * 
 * @returns {Object} Resultado do processamento em lote
 * 
 * Funcionalidades:
 * - Processa múltiplos registros de uma vez
 * - Suporta diferentes tabelas (Mensagens, Projeto, Videos)
 * - Gera embeddings com text-embedding-3-small
 * - Marca registros como processados
 * - Retorna relatório detalhado
 */

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'

const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
const openaiKey = Deno.env.get('OPENAI_API_KEY')!

serve(async (req) => {
  try {
    const { table_name = 'Mensagens', limit = 10, project_id = 71 } = await req.json()
    
    const supabase = createClient(supabaseUrl, supabaseServiceKey)
    
    // Buscar registros pendentes
    const { data: records, error: fetchError } = await supabase
      .from(table_name)
      .select('*')
      .eq('project_id', project_id)
      .or('rag_processed.is.null,rag_processed.is.false')
      .limit(limit)

    if (fetchError || !records || records.length === 0) {
      return new Response(
        JSON.stringify({ 
          error: 'Nenhum registro pendente',
          table: table_name,
          project_id 
        }),
        { headers: { 'Content-Type': 'application/json' } }
      )
    }

    let processed = 0
    const errors = []

    // Processar cada registro
    for (const record of records) {
      try {
        // Preparar conteúdo baseado na tabela
        let content = ''
        let metadata = { project_id }
        
        if (table_name === 'Mensagens') {
          content = record.mensagem || ''
          metadata = {
            ...metadata,
            user_id: record.user_id,
            tipo: record.tipo
          }
        } else if (table_name === 'Projeto') {
          content = `${record['Project name'] || ''} ${record['description service'] || ''} ${record.Keywords || ''}`
          metadata = {
            ...metadata,
            user_id: record['User id'],
            status: record.status
          }
        } else if (table_name === 'Videos') {
          content = `${record.video_title || ''} ${record.video_description || ''}`
          metadata = {
            ...metadata,
            video_id: record.VIDEO,
            channel: record.Channel
          }
        }

        // Gerar embedding
        const embeddingResponse = await fetch('https://api.openai.com/v1/embeddings', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${openaiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            input: content,
            model: 'text-embedding-3-small'
          })
        })

        const embeddingData = await embeddingResponse.json()
        
        if (!embeddingData.data || !embeddingData.data[0]) {
          throw new Error('Embedding não gerado')
        }
        
        const embedding = embeddingData.data[0].embedding

        // Salvar embedding
        const { error: insertError } = await supabase
          .from('rag_embeddings')
          .insert({
            source_table: table_name,
            source_id: record.id.toString(),
            content,
            embedding,
            metadata,
            project_id
          })

        if (insertError) {
          throw insertError
        }

        // Marcar como processado
        await supabase
          .from(table_name)
          .update({
            rag_processed: true,
            rag_processed_at: new Date().toISOString()
          })
          .eq('id', record.id)

        processed++
      } catch (error) {
        errors.push({
          record_id: record.id,
          error: error.message
        })
      }
    }

    return new Response(
      JSON.stringify({
        success: true,
        table: table_name,
        project_id,
        total_records: records.length,
        processed,
        errors: errors.length > 0 ? errors : undefined
      }),
      { headers: { 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
})