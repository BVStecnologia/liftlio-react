{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "YouTubeChannelVideosComponent",
            "id": "YouTubeChannelVideosComponent-KQo7d",
            "name": "results",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-JYuXS",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-YouTubeChannelVideosComponent-KQo7d{œdataTypeœ:œYouTubeChannelVideosComponentœ,œidœ:œYouTubeChannelVideosComponent-KQo7dœ,œnameœ:œresultsœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-JYuXS{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-JYuXSœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "YouTubeChannelVideosComponent-KQo7d",
        "sourceHandle": "{œdataTypeœ:œYouTubeChannelVideosComponentœ,œidœ:œYouTubeChannelVideosComponent-KQo7dœ,œnameœ:œresultsœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "ParserComponent-JYuXS",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-JYuXSœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-tGP7L",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "AnthropicModel-SqDHi",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ParserComponent-tGP7L{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-tGP7Lœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-AnthropicModel-SqDHi{œfieldNameœ:œinput_valueœ,œidœ:œAnthropicModel-SqDHiœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-tGP7L",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-tGP7Lœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "AnthropicModel-SqDHi",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œAnthropicModel-SqDHiœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "MultiPromptInput",
            "id": "MultiPromptInput-l3Sqa",
            "name": "unified_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "system_message",
            "id": "AnthropicModel-SqDHi",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-MultiPromptInput-l3Sqa{œdataTypeœ:œMultiPromptInputœ,œidœ:œMultiPromptInput-l3Sqaœ,œnameœ:œunified_textœ,œoutput_typesœ:[œMessageœ]}-AnthropicModel-SqDHi{œfieldNameœ:œsystem_messageœ,œidœ:œAnthropicModel-SqDHiœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "MultiPromptInput-l3Sqa",
        "sourceHandle": "{œdataTypeœ:œMultiPromptInputœ,œidœ:œMultiPromptInput-l3Sqaœ,œnameœ:œunified_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "AnthropicModel-SqDHi",
        "targetHandle": "{œfieldNameœ:œsystem_messageœ,œidœ:œAnthropicModel-SqDHiœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "AnthropicModel",
            "id": "AnthropicModel-SqDHi",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-uTbYl",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-AnthropicModel-SqDHi{œdataTypeœ:œAnthropicModelœ,œidœ:œAnthropicModel-SqDHiœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-uTbYl{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-uTbYlœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "AnthropicModel-SqDHi",
        "sourceHandle": "{œdataTypeœ:œAnthropicModelœ,œidœ:œAnthropicModel-SqDHiœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-uTbYl",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-uTbYlœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "YouTubeVideoDetailsWithTranscript",
            "id": "YouTubeVideoDetailsWithTranscript-ZrYJE",
            "name": "video_data",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-tGP7L",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-YouTubeVideoDetailsWithTranscript-ZrYJE{œdataTypeœ:œYouTubeVideoDetailsWithTranscriptœ,œidœ:œYouTubeVideoDetailsWithTranscript-ZrYJEœ,œnameœ:œvideo_dataœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-tGP7L{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-tGP7Lœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "YouTubeVideoDetailsWithTranscript-ZrYJE",
        "sourceHandle": "{œdataTypeœ:œYouTubeVideoDetailsWithTranscriptœ,œidœ:œYouTubeVideoDetailsWithTranscript-ZrYJEœ,œnameœ:œvideo_dataœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "ParserComponent-tGP7L",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-tGP7Lœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-JYuXS",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "video_ids",
            "id": "YouTubeVideoDetailsWithTranscript-ZrYJE",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ParserComponent-JYuXS{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-JYuXSœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-YouTubeVideoDetailsWithTranscript-ZrYJE{œfieldNameœ:œvideo_idsœ,œidœ:œYouTubeVideoDetailsWithTranscript-ZrYJEœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-JYuXS",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-JYuXSœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "YouTubeVideoDetailsWithTranscript-ZrYJE",
        "targetHandle": "{œfieldNameœ:œvideo_idsœ,œidœ:œYouTubeVideoDetailsWithTranscript-ZrYJEœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "CanalVideosComponent",
            "id": "CanalVideosComponent-KJuP3",
            "name": "youtube_canal_id",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "channel_id",
            "id": "YouTubeChannelVideosComponent-KQo7d",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__CanalVideosComponent-KJuP3{œdataTypeœ:œCanalVideosComponentœ,œidœ:œCanalVideosComponent-KJuP3œ,œnameœ:œyoutube_canal_idœ,œoutput_typesœ:[œMessageœ]}-YouTubeChannelVideosComponent-KQo7d{œfieldNameœ:œchannel_idœ,œidœ:œYouTubeChannelVideosComponent-KQo7dœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "CanalVideosComponent-KJuP3",
        "sourceHandle": "{œdataTypeœ:œCanalVideosComponentœ,œidœ:œCanalVideosComponent-KJuP3œ,œnameœ:œyoutube_canal_idœ,œoutput_typesœ:[œMessageœ]}",
        "target": "YouTubeChannelVideosComponent-KQo7d",
        "targetHandle": "{œfieldNameœ:œchannel_idœ,œidœ:œYouTubeChannelVideosComponent-KQo7dœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-aPhAl",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "canal_tabela_id",
            "id": "CanalVideosComponent-KJuP3",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ChatInput-aPhAl{œdataTypeœ:œChatInputœ,œidœ:œChatInput-aPhAlœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-CanalVideosComponent-KJuP3{œfieldNameœ:œcanal_tabela_idœ,œidœ:œCanalVideosComponent-KJuP3œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-aPhAl",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-aPhAlœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "CanalVideosComponent-KJuP3",
        "targetHandle": "{œfieldNameœ:œcanal_tabela_idœ,œidœ:œCanalVideosComponent-KJuP3œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ProjetoDadosComponent",
            "id": "ProjetoDadosComponent-Rcjqu",
            "name": "projeto_dados",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-K2u5R",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ProjetoDadosComponent-Rcjqu{œdataTypeœ:œProjetoDadosComponentœ,œidœ:œProjetoDadosComponent-Rcjquœ,œnameœ:œprojeto_dadosœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-K2u5R{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-K2u5Rœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ProjetoDadosComponent-Rcjqu",
        "sourceHandle": "{œdataTypeœ:œProjetoDadosComponentœ,œidœ:œProjetoDadosComponent-Rcjquœ,œnameœ:œprojeto_dadosœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "ParserComponent-K2u5R",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-K2u5Rœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-K2u5R",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "prompt2",
            "id": "MultiPromptInput-l3Sqa",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-K2u5R{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-K2u5Rœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-MultiPromptInput-l3Sqa{œfieldNameœ:œprompt2œ,œidœ:œMultiPromptInput-l3Sqaœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-K2u5R",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-K2u5Rœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "MultiPromptInput-l3Sqa",
        "targetHandle": "{œfieldNameœ:œprompt2œ,œidœ:œMultiPromptInput-l3Sqaœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-aPhAl",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "canal_id",
            "id": "ProjetoDadosComponent-Rcjqu",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ChatInput-aPhAl{œdataTypeœ:œChatInputœ,œidœ:œChatInput-aPhAlœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-ProjetoDadosComponent-Rcjqu{œfieldNameœ:œcanal_idœ,œidœ:œProjetoDadosComponent-Rcjquœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-aPhAl",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-aPhAlœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ProjetoDadosComponent-Rcjqu",
        "targetHandle": "{œfieldNameœ:œcanal_idœ,œidœ:œProjetoDadosComponent-Rcjquœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "YouTubeChannelVideosComponent-KQo7d",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Obtém os últimos vídeos de um canal específico do YouTube com opções de filtragem e exclusão de IDs específicos.",
            "display_name": "YouTube Channel Videos",
            "documentation": "",
            "edited": true,
            "field_order": [
              "channel_id",
              "api_key",
              "max_results",
              "excluded_video_ids",
              "order",
              "date_filter",
              "include_metadata",
              "debug_mode"
            ],
            "frozen": false,
            "icon": "YouTube",
            "legacy": false,
            "lf_version": "1.5.0.post1",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Vídeos do Canal",
                "hidden": false,
                "method": "get_channel_videos",
                "name": "results",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Chave da API do YouTube",
                "dynamic": false,
                "info": "Sua chave da API de Dados do YouTube.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "Youtube"
              },
              "channel_id": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "ID do Canal",
                "dynamic": false,
                "info": "ID do canal do YouTube (ex: UC-lHJZR3Gqxm24_Vd_AJ5Yw)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "channel_id",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from contextlib import contextmanager\nfrom datetime import datetime, timedelta\nfrom typing import Optional, List\n\nimport pandas as pd\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\nfrom langflow.custom import Component\nfrom langflow.inputs import (\n    BoolInput, \n    DropdownInput, \n    IntInput, \n    MessageTextInput, \n    SecretStrInput\n)\nfrom langflow.schema import DataFrame\nfrom langflow.template import Output\n\n\nclass YouTubeChannelVideosComponent(Component):\n    \"\"\"Componente que obtém os últimos vídeos de um canal específico do YouTube com opção de excluir vídeos específicos.\"\"\"\n\n    display_name: str = \"YouTube Channel Videos\"\n    description: str = \"Obtém os últimos vídeos de um canal específico do YouTube com opções de filtragem e exclusão de IDs específicos.\"\n    icon: str = \"YouTube\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"channel_id\",\n            display_name=\"ID do Canal\",\n            info=\"ID do canal do YouTube (ex: UC-lHJZR3Gqxm24_Vd_AJ5Yw)\",\n            tool_mode=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Chave da API do YouTube\",\n            info=\"Sua chave da API de Dados do YouTube.\",\n            required=True,\n        ),\n        IntInput(\n            name=\"max_results\",\n            display_name=\"Resultados Máximos\",\n            value=10,\n            info=\"Número máximo de vídeos para retornar.\",\n        ),\n        MessageTextInput(\n            name=\"excluded_video_ids\",\n            display_name=\"IDs de Vídeos Excluídos\",\n            info=\"Lista de IDs de vídeos a serem excluídos dos resultados (separados por vírgula).\",\n            value=\"\",\n            required=False,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Ordem de Classificação\",\n            options=[\"date\", \"viewCount\", \"rating\", \"title\"],\n            value=\"date\",\n            info=\"Ordem de classificação para os resultados.\",\n        ),\n        DropdownInput(\n            name=\"date_filter\",\n            display_name=\"Filtro de Data\",\n            options=[\"qualquer data\", \"último dia\", \"última semana\", \"último mês\", \"últimos 3 meses\", \"últimos 6 meses\", \"último ano\"],\n            value=\"qualquer data\",\n            info=\"Filtrar vídeos publicados dentro deste período.\",\n        ),\n        BoolInput(\n            name=\"include_metadata\",\n            display_name=\"Incluir Metadados\",\n            value=True,\n            info=\"Incluir metadados de vídeo como descrição e estatísticas.\",\n        ),\n        BoolInput(\n            name=\"debug_mode\",\n            display_name=\"Modo Debug\",\n            value=False,\n            info=\"Ativar logs de depuração.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"results\", display_name=\"Vídeos do Canal\", method=\"get_channel_videos\"),\n    ]\n\n    @contextmanager\n    def youtube_client(self):\n        \"\"\"Gerenciador de contexto para o cliente da API do YouTube.\"\"\"\n        client = build(\"youtube\", \"v3\", developerKey=self.api_key)\n        try:\n            yield client\n        finally:\n            client.close()\n    \n    def _get_date_filter(self) -> Optional[str]:\n        \"\"\"Converte o filtro de data selecionado para uma data ISO 8601.\"\"\"\n        if self.date_filter == \"qualquer data\":\n            return None\n            \n        now = datetime.now()\n        \n        if self.date_filter == \"último dia\":\n            date = now - timedelta(days=1)\n        elif self.date_filter == \"última semana\":\n            date = now - timedelta(weeks=1)\n        elif self.date_filter == \"último mês\":\n            date = now - timedelta(days=30)\n        elif self.date_filter == \"últimos 3 meses\":\n            date = now - timedelta(days=90)\n        elif self.date_filter == \"últimos 6 meses\":\n            date = now - timedelta(days=180)\n        elif self.date_filter == \"último ano\":\n            date = now - timedelta(days=365)\n        else:\n            return None\n            \n        return date.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n    \n    def _normalize_video_id(self, video_id: str) -> str:\n        \"\"\"Normaliza um ID de vídeo para comparação consistente.\"\"\"\n        if not video_id:\n            return \"\"\n        return video_id.strip().lower()\n    \n    def _parse_excluded_video_ids(self) -> List[str]:\n        \"\"\"Converte a string de IDs excluídos em uma lista de IDs normalizados.\"\"\"\n        excluded_ids = []\n        \n        if hasattr(self, 'excluded_video_ids') and self.excluded_video_ids:\n            # Processar entrada de texto\n            if isinstance(self.excluded_video_ids, str):\n                # Dividir por vírgula e normalizar\n                excluded_ids = [self._normalize_video_id(vid) for vid in self.excluded_video_ids.split(',')]\n            # Processar possível objeto Message\n            elif hasattr(self.excluded_video_ids, 'text'):\n                # Dividir por vírgula e normalizar\n                excluded_ids = [self._normalize_video_id(vid) for vid in self.excluded_video_ids.text.split(',')]\n            \n            # Remover IDs vazios após a normalização\n            excluded_ids = [vid for vid in excluded_ids if vid]\n            \n        return excluded_ids\n    \n    def _log_debug(self, message: str) -> None:\n        \"\"\"Registra mensagens de debug se o modo debug estiver ativado.\"\"\"\n        if hasattr(self, 'debug_mode') and self.debug_mode:\n            print(f\"[DEBUG] {message}\")\n\n    def get_channel_videos(self) -> DataFrame:\n        \"\"\"Obtém os últimos vídeos de um canal específico do YouTube, excluindo IDs específicos.\"\"\"\n        try:\n            if not self.channel_id:\n                self._log_debug(\"Erro: ID do canal não fornecido\")\n                return DataFrame(pd.DataFrame({\"error\": [\"ID do canal não fornecido\"]}))\n            \n            # Obter lista de IDs excluídos\n            excluded_video_ids = self._parse_excluded_video_ids()\n            if excluded_video_ids:\n                self._log_debug(f\"IDs de vídeos a serem excluídos: {excluded_video_ids}\")\n                self._log_debug(f\"Total de IDs excluídos: {len(excluded_video_ids)}\")\n                \n            # Obter o filtro de data\n            published_after = self._get_date_filter()\n            \n            self._log_debug(f\"Buscando vídeos para o canal: {self.channel_id}\")\n            \n            all_results = []\n            filtered_count = 0\n            \n            with self.youtube_client() as youtube:\n                # Primeiro, precisamos obter a playlist de \"uploads\" do canal\n                # Isso é feito consultando os detalhes do canal\n                channel_response = youtube.channels().list(\n                    part=\"contentDetails\",\n                    id=self.channel_id\n                ).execute()\n                \n                if not channel_response.get(\"items\"):\n                    self._log_debug(f\"Canal não encontrado com ID: {self.channel_id}\")\n                    return DataFrame(pd.DataFrame({\"error\": [f\"Canal não encontrado com ID: {self.channel_id}\"]}))\n                \n                # Obter o ID da playlist de uploads\n                try:\n                    uploads_playlist_id = channel_response.get(\"items\", [{}])[0].get(\"contentDetails\", {}).get(\"relatedPlaylists\", {}).get(\"uploads\", \"\")\n                    if not uploads_playlist_id:\n                        raise ValueError(\"Não foi possível obter a playlist de uploads do canal\")\n                except (IndexError, KeyError) as e:\n                    self._log_debug(f\"Erro ao obter playlist de uploads: {str(e)}\")\n                    return DataFrame(pd.DataFrame({\"error\": [f\"Erro ao obter playlist de uploads: {str(e)}\"]}))\n                \n                self._log_debug(f\"ID da playlist de uploads: {uploads_playlist_id}\")\n                \n                # Preparar parâmetros para listar os itens da playlist\n                # Aumentamos o max_results para compensar os que serão filtrados\n                buffer_factor = 2 if excluded_video_ids else 1\n                playlist_params = {\n                    \"playlistId\": uploads_playlist_id,\n                    \"part\": \"snippet,contentDetails\",\n                    \"maxResults\": min(50, self.max_results * buffer_factor)  # Máximo permitido pela API é 50\n                }\n                \n                # Executar a busca na playlist\n                playlist_items = youtube.playlistItems().list(**playlist_params).execute()\n                \n                video_ids = []\n                \n                # Processar resultados da playlist\n                for item in playlist_items.get(\"items\", []):\n                    try:\n                        snippet = item.get(\"snippet\", {})\n                        content_details = item.get(\"contentDetails\", {})\n                        video_id = content_details.get(\"videoId\", \"\")\n                        published_at = snippet.get(\"publishedAt\", \"\")\n                        \n                        if not video_id:\n                            continue\n                        \n                        # Verificar se o vídeo deve ser excluído\n                        normalized_id = self._normalize_video_id(video_id)\n                        if normalized_id in excluded_video_ids:\n                            filtered_count += 1\n                            self._log_debug(f\"Excluído: vídeo {video_id} está na lista de excluídos\")\n                            continue\n                        \n                        # Aplicar filtro de data se especificado\n                        if published_after and published_at < published_after:\n                            filtered_count += 1\n                            self._log_debug(f\"Excluído: vídeo {video_id} foi publicado antes do filtro de data\")\n                            continue\n                        \n                        video_ids.append(video_id)\n                        \n                        result = {\n                            \"video_id\": video_id,\n                            \"title\": snippet.get(\"title\", \"\"),\n                            \"description\": snippet.get(\"description\", \"\"),\n                            \"published_at\": published_at,\n                            \"thumbnail_url\": snippet.get(\"thumbnails\", {}).get(\"default\", {}).get(\"url\", \"\"),\n                        }\n                        \n                        all_results.append(result)\n                        \n                        # Se já temos resultados suficientes, parar\n                        if len(all_results) >= self.max_results:\n                            break\n                    except Exception as e:\n                        self._log_debug(f\"Erro ao processar item da playlist: {str(e)}\")\n                        continue\n                \n                # Se temos poucos resultados e há uma próxima página, continuar buscando\n                next_page_token = playlist_items.get(\"nextPageToken\")\n                while next_page_token and len(all_results) < self.max_results:\n                    playlist_params[\"pageToken\"] = next_page_token\n                    playlist_items = youtube.playlistItems().list(**playlist_params).execute()\n                    \n                    for item in playlist_items.get(\"items\", []):\n                        try:\n                            snippet = item.get(\"snippet\", {})\n                            content_details = item.get(\"contentDetails\", {})\n                            video_id = content_details.get(\"videoId\", \"\")\n                            published_at = snippet.get(\"publishedAt\", \"\")\n                            \n                            if not video_id:\n                                continue\n                            \n                            # Verificar se o vídeo deve ser excluído\n                            normalized_id = self._normalize_video_id(video_id)\n                            if normalized_id in excluded_video_ids:\n                                filtered_count += 1\n                                continue\n                            \n                            # Aplicar filtro de data se especificado\n                            if published_after and published_at < published_after:\n                                filtered_count += 1\n                                continue\n                            \n                            video_ids.append(video_id)\n                            \n                            result = {\n                                \"video_id\": video_id,\n                                \"title\": snippet.get(\"title\", \"\"),\n                                \"description\": snippet.get(\"description\", \"\"),\n                                \"published_at\": published_at,\n                                \"thumbnail_url\": snippet.get(\"thumbnails\", {}).get(\"default\", {}).get(\"url\", \"\"),\n                            }\n                            \n                            all_results.append(result)\n                            \n                            # Se já temos resultados suficientes, parar\n                            if len(all_results) >= self.max_results:\n                                break\n                        except Exception as e:\n                            self._log_debug(f\"Erro ao processar item da playlist (página adicional): {str(e)}\")\n                            continue\n                    \n                    # Atualizar o token da próxima página\n                    next_page_token = playlist_items.get(\"nextPageToken\")\n                \n                # Se solicitado, obter metadados adicionais\n                if self.include_metadata and video_ids:\n                    # Dividir em chunks de 50 (limite da API)\n                    chunks = [video_ids[i:i + 50] for i in range(0, len(video_ids), 50)]\n                    \n                    for chunk in chunks:\n                        try:\n                            videos_response = youtube.videos().list(\n                                part=\"statistics,contentDetails\",\n                                id=\",\".join(chunk)\n                            ).execute()\n                            \n                            # Criar um dicionário de metadados por video_id\n                            metadata_map = {}\n                            for item in videos_response.get(\"items\", []):\n                                try:\n                                    statistics = item.get(\"statistics\", {})\n                                    content_details = item.get(\"contentDetails\", {})\n                                    \n                                    metadata_map[item.get(\"id\", \"\")] = {\n                                        \"view_count\": int(statistics.get(\"viewCount\", 0)),\n                                        \"like_count\": int(statistics.get(\"likeCount\", 0)),\n                                        \"comment_count\": int(statistics.get(\"commentCount\", 0)),\n                                        \"duration\": content_details.get(\"duration\", \"\")  # Corrigido para usar .get()\n                                    }\n                                except Exception as e:\n                                    self._log_debug(f\"Erro ao processar metadados de vídeo: {str(e)}\")\n                                    continue\n                            \n                            # Atualizar os resultados com os metadados\n                            for result in all_results:\n                                vid_id = result.get(\"video_id\", \"\")\n                                if vid_id in metadata_map:\n                                    result.update(metadata_map[vid_id])\n                        except Exception as e:\n                            self._log_debug(f\"Erro ao obter metadados de vídeos: {str(e)}\")\n                            # Continuar mesmo se não conseguir obter metadados\n                            continue\n                \n                # Ordenar os resultados conforme solicitado\n                if all_results:\n                    try:\n                        if self.order == \"date\":\n                            all_results.sort(key=lambda x: x.get(\"published_at\", \"\"), reverse=True)\n                        elif self.order == \"viewCount\" and self.include_metadata:\n                            all_results.sort(key=lambda x: x.get(\"view_count\", 0), reverse=True)\n                        elif self.order == \"title\":\n                            all_results.sort(key=lambda x: x.get(\"title\", \"\"))\n                    except Exception as e:\n                        self._log_debug(f\"Erro ao ordenar resultados: {str(e)}\")\n                        # Continuar mesmo se falhar na ordenação\n            \n            self._log_debug(f\"Total de vídeos filtrados: {filtered_count}\")\n            \n            # Se não houver resultados após filtrar\n            if not all_results:\n                self._log_debug(\"Nenhum vídeo encontrado com os filtros aplicados\")\n                return DataFrame(pd.DataFrame({\"message\": [\"Nenhum vídeo encontrado com os filtros aplicados\"]}))\n            \n            self._log_debug(f\"Total de vídeos encontrados: {len(all_results)}\")\n            return DataFrame(pd.DataFrame(all_results))\n\n        except HttpError as e:\n            error_message = f\"Erro na API do YouTube: {e!s}\"\n            self._log_debug(f\"Erro HTTP: {error_message}\")\n            return DataFrame(pd.DataFrame({\"error\": [error_message]}))\n        except Exception as e:\n            error_message = f\"Erro inesperado: {str(e)}\"\n            self._log_debug(f\"Exceção: {error_message}\")\n            return DataFrame(pd.DataFrame({\"error\": [error_message]}))"
              },
              "date_filter": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Filtro de Data",
                "dynamic": false,
                "info": "Filtrar vídeos publicados dentro deste período.",
                "load_from_db": false,
                "name": "date_filter",
                "options": [
                  "qualquer data",
                  "último dia",
                  "última semana",
                  "último mês",
                  "últimos 3 meses",
                  "últimos 6 meses",
                  "último ano"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "último dia"
              },
              "debug_mode": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Modo Debug",
                "dynamic": false,
                "info": "Ativar logs de depuração.",
                "list": false,
                "list_add_label": "Add More",
                "name": "debug_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "excluded_video_ids": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "IDs de Vídeos Excluídos",
                "dynamic": false,
                "info": "Lista de IDs de vídeos a serem excluídos dos resultados (separados por vírgula).",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "excluded_video_ids",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "include_metadata": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Incluir Metadados",
                "dynamic": false,
                "info": "Incluir metadados de vídeo como descrição e estatísticas.",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_metadata",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "max_results": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Resultados Máximos",
                "dynamic": false,
                "info": "Número máximo de vídeos para retornar.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_results",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 20
              },
              "order": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Ordem de Classificação",
                "dynamic": false,
                "info": "Ordem de classificação para os resultados.",
                "name": "order",
                "options": [
                  "date",
                  "viewCount",
                  "rating",
                  "title"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "date"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "YouTubeChannelVideosComponent"
        },
        "dragging": false,
        "id": "YouTubeChannelVideosComponent-KQo7d",
        "measured": {
          "height": 691,
          "width": 320
        },
        "position": {
          "x": 1253.181286535167,
          "y": -214.16764873298504
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-JYuXS",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "hidden": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{video_id},"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-JYuXS",
        "measured": {
          "height": 329,
          "width": 320
        },
        "position": {
          "x": 1635.509504734568,
          "y": -371.36955521499203
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "YouTubeTranscribeAPI-2BaU6",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Obtém transcrições do YouTube usando a API personalizada com opção de truncamento por timestamp.",
            "display_name": "YouTube Transcribe API",
            "documentation": "",
            "edited": true,
            "field_order": [
              "video_url_or_id",
              "max_timestamp",
              "timestamp_format",
              "debug_mode"
            ],
            "frozen": false,
            "icon": "YouTube",
            "legacy": false,
            "lf_version": "1.3.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Dados da Transcrição",
                "hidden": null,
                "method": "extract_transcript",
                "name": "transcript_data",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import requests\nimport pandas as pd\nimport re\nfrom datetime import datetime, timedelta\n\nfrom langflow.custom import Component\nfrom langflow.inputs import SecretStrInput, BoolInput, IntInput, DropdownInput\nfrom langflow.schema import DataFrame\nfrom langflow.template import Output\n\nclass YouTubeTranscribeAPI(Component):\n    \"\"\"Componente que utiliza a API existente para obter transcrições do YouTube com opção de truncamento por timestamp.\"\"\"\n\n    display_name: str = \"YouTube Transcribe API\"\n    description: str = \"Obtém transcrições do YouTube usando a API personalizada com opção de truncamento por timestamp.\"\n    icon: str = \"YouTube\"\n\n    inputs = [\n        SecretStrInput(\n            name=\"video_url_or_id\",\n            display_name=\"URL ou ID do Vídeo\",\n            info=\"URL completa do YouTube ou apenas o ID do vídeo.\",\n            required=True,\n        ),\n        IntInput(\n            name=\"max_timestamp\",\n            display_name=\"Timestamp Máximo (minutos)\",\n            info=\"Tempo máximo da transcrição em minutos (0 = sem limite).\",\n            value=0,\n        ),\n        DropdownInput(\n            name=\"timestamp_format\",\n            display_name=\"Formato de Timestamp\",\n            options=[\"incluir\", \"excluir\", \"apenas_texto\"],\n            value=\"incluir\",\n            info=\"Como tratar os timestamps na saída: incluir, excluir ou retornar apenas o texto.\",\n        ),\n        BoolInput(\n            name=\"debug_mode\",\n            display_name=\"Modo Debug\",\n            value=True,\n            info=\"Ativar logs de depuração.\",\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"transcript_data\", display_name=\"Dados da Transcrição\", method=\"extract_transcript\"),\n    ]\n    \n    def _log_debug(self, message: str) -> None:\n        \"\"\"Registra mensagens de debug se o modo debug estiver ativado.\"\"\"\n        if hasattr(self, 'debug_mode') and self.debug_mode:\n            print(f\"[DEBUG] {message}\")\n    \n    def _extract_video_id(self, url_or_id: str) -> str:\n        \"\"\"Extrai o ID do vídeo a partir de uma URL ou retorna o próprio ID.\"\"\"\n        # Se parece ser apenas um ID (sem http ou youtube.com)\n        if not url_or_id.startswith(('http://', 'https://')) and '/' not in url_or_id:\n            return url_or_id\n            \n        # Padrões de URL do YouTube\n        patterns = [\n            r'(?:v=|\\/)([0-9A-Za-z_-]{11}).*',  # youtube.com/watch?v=ID ou youtube.com/v/ID\n            r'(?:embed\\/)([0-9A-Za-z_-]{11})',  # youtube.com/embed/ID\n            r'(?:youtu\\.be\\/)([0-9A-Za-z_-]{11})'  # youtu.be/ID\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, url_or_id)\n            if match:\n                return match.group(1)\n                \n        # Se não encontrou um padrão conhecido, retorna o original\n        return url_or_id\n    \n    def _get_transcript_from_api(self, video_url: str) -> dict:\n        \"\"\"Obtém a transcrição usando a API existente.\"\"\"\n        result = {\n            \"success\": False,\n            \"transcript\": \"\",\n            \"error\": None\n        }\n        \n        try:\n            # Garantir que temos uma URL completa\n            if not video_url.startswith(('http://', 'https://')):\n                video_url = f\"https://www.youtube.com/watch?v={video_url}\"\n            \n            self._log_debug(f\"Enviando requisição para API com URL: {video_url}\")\n            \n            # Fazer a requisição para a API\n            response = requests.post(\n                'https://youtube-transcribe.fly.dev/transcribe',\n                json={\"url\": video_url},\n                headers={'Content-Type': 'application/json'},\n                timeout=300  # 5 minutos (mesmo que você configurou no SQL)\n            )\n            \n            # Verificar se a requisição foi bem-sucedida\n            if response.status_code == 200:\n                data = response.json()\n                \n                if 'transcription' in data and data['transcription']:\n                    result[\"transcript\"] = data['transcription']\n                    result[\"success\"] = True\n                    self._log_debug(\"Transcrição obtida com sucesso da API\")\n                else:\n                    result[\"error\"] = \"A API retornou uma resposta vazia para a transcrição\"\n                    self._log_debug(result[\"error\"])\n            else:\n                result[\"error\"] = f\"Erro na requisição à API: {response.status_code} - {response.text}\"\n                self._log_debug(result[\"error\"])\n                \n        except Exception as e:\n            result[\"error\"] = str(e)\n            self._log_debug(f\"Erro ao obter transcrição da API: {str(e)}\")\n        \n        return result\n    \n    def _truncate_transcript_by_timestamp(self, transcript: str, max_minutes: int, timestamp_format: str) -> str:\n        \"\"\"Trunca a transcrição pelo timestamp máximo especificado em minutos.\"\"\"\n        if not max_minutes or max_minutes <= 0:\n            # Se max_minutes for 0 ou negativo, não truncar\n            self._log_debug(\"Sem truncamento por timestamp (valor 0 ou negativo)\")\n            \n            # Ainda aplicamos a formatação de timestamp se solicitado\n            if timestamp_format == \"excluir\":\n                # Remove os timestamps mas mantém o texto\n                return re.sub(r'\\[\\d{2}:\\d{2}:\\d{2}\\]\\s*', '', transcript)\n            elif timestamp_format == \"apenas_texto\":\n                # Remove os timestamps e junta todo o texto sem quebras de linha\n                cleaned_text = re.sub(r'\\[\\d{2}:\\d{2}:\\d{2}\\]\\s*', '', transcript)\n                return ' '.join(cleaned_text.split())\n            else:\n                # Mantém o formato original\n                return transcript\n        \n        self._log_debug(f\"Truncando transcrição em {max_minutes} minutos\")\n        \n        # Converter minutos para segundos para facilitar a comparação\n        max_seconds = max_minutes * 60\n        \n        # Regex para extrair timestamps no formato [HH:MM:SS]\n        timestamp_pattern = r'\\[(\\d{2}):(\\d{2}):(\\d{2})\\]'\n        \n        lines = transcript.split('\\n')\n        truncated_lines = []\n        \n        for line in lines:\n            match = re.search(timestamp_pattern, line)\n            if match:\n                hours, minutes, seconds = map(int, match.groups())\n                total_seconds = hours * 3600 + minutes * 60 + seconds\n                \n                if total_seconds <= max_seconds:\n                    truncated_lines.append(line)\n                else:\n                    # Encontrou uma linha que ultrapassa o limite de tempo\n                    self._log_debug(f\"Truncamento em: {hours:02d}:{minutes:02d}:{seconds:02d}\")\n                    break\n            else:\n                # Linhas sem timestamp (como cabeçalhos) são mantidas se estiverem antes do ponto de truncamento\n                if truncated_lines:  # Só adiciona se já temos algumas linhas válidas\n                    truncated_lines.append(line)\n        \n        # Aplicar a formatação de timestamp solicitada\n        truncated_transcript = '\\n'.join(truncated_lines)\n        \n        if timestamp_format == \"excluir\":\n            # Remove os timestamps mas mantém o texto com quebras de linha\n            return re.sub(r'\\[\\d{2}:\\d{2}:\\d{2}\\]\\s*', '', truncated_transcript)\n        elif timestamp_format == \"apenas_texto\":\n            # Remove os timestamps e junta todo o texto sem quebras de linha\n            cleaned_text = re.sub(r'\\[\\d{2}:\\d{2}:\\d{2}\\]\\s*', '', truncated_transcript)\n            return ' '.join(cleaned_text.split())\n        else:\n            # Mantém o formato original com timestamps\n            return truncated_transcript\n    \n    def extract_transcript(self) -> DataFrame:\n        \"\"\"Extrai a transcrição do vídeo usando a API e aplica truncamento se necessário.\"\"\"\n        input_value = self.video_url_or_id.strip()\n        \n        if not input_value:\n            return DataFrame(pd.DataFrame({\"error\": [\"URL ou ID de vídeo não fornecido\"]}))\n        \n        self._log_debug(f\"Iniciando extração para: {input_value}\")\n        \n        # Extrair o ID do vídeo se for uma URL\n        video_id = self._extract_video_id(input_value)\n        self._log_debug(f\"ID do vídeo extraído: {video_id}\")\n        \n        # Obter transcrição usando a API\n        result = self._get_transcript_from_api(input_value)\n        \n        # Processar e truncar a transcrição se necessário\n        if result[\"success\"] and result[\"transcript\"]:\n            max_timestamp = getattr(self, 'max_timestamp', 0)\n            timestamp_format = getattr(self, 'timestamp_format', 'incluir')\n            \n            # Truncar a transcrição pelo timestamp\n            truncated_transcript = self._truncate_transcript_by_timestamp(\n                result[\"transcript\"], \n                max_timestamp,\n                timestamp_format\n            )\n            \n            # Atualizar o resultado com a transcrição truncada\n            result[\"transcript\"] = truncated_transcript\n            \n            # Adicionar metadados sobre o truncamento\n            result[\"truncated\"] = max_timestamp > 0\n            result[\"max_timestamp_minutes\"] = max_timestamp\n            result[\"timestamp_format\"] = timestamp_format\n        \n        # Preparar o resultado\n        output = {\n            \"video_id\": video_id,\n            \"success\": result[\"success\"],\n            \"transcript\": result[\"transcript\"],\n        }\n        \n        if not result[\"success\"]:\n            output[\"error\"] = result[\"error\"]\n        \n        # Registrar o resultado final\n        self._log_debug(f\"Resultado final: {'Sucesso' if result['success'] else 'Falha'}\")\n        \n        # Converter para DataFrame e retornar\n        return DataFrame(pd.DataFrame([output]))"
              },
              "debug_mode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Modo Debug",
                "dynamic": false,
                "info": "Ativar logs de depuração.",
                "list": false,
                "list_add_label": "Add More",
                "name": "debug_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "max_timestamp": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Timestamp Máximo (minutos)",
                "dynamic": false,
                "info": "Tempo máximo da transcrição em minutos (0 = sem limite).",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_timestamp",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 30
              },
              "timestamp_format": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Formato de Timestamp",
                "dynamic": false,
                "info": "Como tratar os timestamps na saída: incluir, excluir ou retornar apenas o texto.",
                "name": "timestamp_format",
                "options": [
                  "incluir",
                  "excluir",
                  "apenas_texto"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "incluir"
              },
              "video_url_or_id": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "URL ou ID do Vídeo",
                "dynamic": false,
                "info": "URL completa do YouTube ou apenas o ID do vídeo.",
                "input_types": [],
                "load_from_db": false,
                "name": "video_url_or_id",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "qekK9B9cSwQ"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "YouTubeTranscribeAPI"
        },
        "dragging": false,
        "id": "YouTubeTranscribeAPI-2BaU6",
        "measured": {
          "height": 443,
          "width": 320
        },
        "position": {
          "x": 7319.284388258192,
          "y": 2445.71530244373
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CanalVideosComponent-KJuP3",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Recupera o ID do canal e a lista de IDs de vídeos do Supabase",
            "display_name": "Canal e Videos YouTube",
            "documentation": "",
            "edited": true,
            "field_order": [
              "canal_tabela_id",
              "supabase_url",
              "supabase_key"
            ],
            "frozen": false,
            "icon": "YouTube",
            "legacy": false,
            "lf_version": "1.5.0.post1",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "ID do Canal",
                "hidden": false,
                "method": "get_canal_id",
                "name": "youtube_canal_id",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "IDs dos Vídeos",
                "hidden": false,
                "method": "get_video_ids",
                "name": "video_ids",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "ID da Tabela Canal 1",
                "hidden": false,
                "method": "get_tabela_canal_id",
                "name": "tabela_canal_id",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "ID da Tabela Canal 2",
                "hidden": null,
                "method": "get_tabela_canal_id_2",
                "name": "tabela_canal_id_2",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "ID da Tabela Canal 3",
                "hidden": null,
                "method": "get_tabela_canal_id_3",
                "name": "tabela_canal_id_3",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "canal_tabela_id": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "ID ou Nome da Tabela Canal",
                "dynamic": false,
                "info": "ID ou identificador da tabela canal no banco de dados",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "canal_tabela_id",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "1118"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.inputs import MultilineInput, SecretStrInput, StrInput\nfrom langflow.template import Output\nfrom langflow.schema.message import Message\nfrom loguru import logger\nimport asyncio\n\nclass CanalVideosComponent(Component):\n    display_name = \"Canal e Videos YouTube\"\n    description = \"Recupera o ID do canal e a lista de IDs de vídeos do Supabase\"\n    icon = \"YouTube\"\n    name = \"CanalVideosComponent\"\n\n    # Cache para armazenar os dados recuperados\n    _data_cache = {}\n    # Controle de requisições pendentes\n    _pending_requests = {}\n\n    inputs = [\n        # Alterado para MultilineInput para aceitar texto dinâmico\n        MultilineInput(\n            name=\"canal_tabela_id\",\n            display_name=\"ID ou Nome da Tabela Canal\",\n            info=\"ID ou identificador da tabela canal no banco de dados\",\n            required=True,\n        ),\n        StrInput(\n            name=\"supabase_url\",\n            display_name=\"Supabase URL\",\n            value=\"https://suqjifkhmekcdflwowiw.supabase.co\",\n            info=\"URL base do Supabase\",\n        ),\n        SecretStrInput(\n            name=\"supabase_key\",\n            display_name=\"Supabase Key\",\n            info=\"Chave de API do Supabase\",\n            required=True,\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"ID do Canal\", name=\"youtube_canal_id\", method=\"get_canal_id\"),\n        Output(display_name=\"IDs dos Vídeos\", name=\"video_ids\", method=\"get_video_ids\"),\n        Output(display_name=\"ID da Tabela Canal 1\", name=\"tabela_canal_id\", method=\"get_tabela_canal_id\"),\n        Output(display_name=\"ID da Tabela Canal 2\", name=\"tabela_canal_id_2\", method=\"get_tabela_canal_id_2\"),\n        Output(display_name=\"ID da Tabela Canal 3\", name=\"tabela_canal_id_3\", method=\"get_tabela_canal_id_3\"),\n    ]\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Identificador único para este componente\n        self.instance_id = id(self)\n        # Garantir que este componente tenha uma entrada no cache\n        CanalVideosComponent._data_cache[self.instance_id] = {}\n        CanalVideosComponent._pending_requests[self.instance_id] = None\n\n    def _process_input(self, input_value):\n        \"\"\"Processa os valores de entrada para garantir compatibilidade.\"\"\"\n        if input_value is None:\n            return \"\"\n        if isinstance(input_value, Message):\n            return input_value.text or \"\"\n        if isinstance(input_value, dict) and \"text\" in input_value:\n            return input_value[\"text\"] or \"\"\n        return str(input_value)\n\n    async def obter_canal_e_videos(self) -> dict:\n        \"\"\"Chama a função obter_canal_e_videos no Supabase e retorna os dados.\"\"\"\n        try:\n            import httpx\n            \n            canal_id_str = self._process_input(self.canal_tabela_id)\n            supabase_url = self._process_input(self.supabase_url)\n            supabase_key = self._process_input(self.supabase_key)\n            \n            # Validações básicas - apenas verificar se não está vazio\n            if not canal_id_str.strip():\n                raise ValueError(\"Identificador da tabela canal não pode ser vazio\")\n            \n            # Preparar o valor para API - permitindo tanto números quanto texto\n            if canal_id_str.strip().isdigit():\n                canal_id_value = int(canal_id_str.strip())\n            else:\n                canal_id_value = canal_id_str.strip()\n            \n            # Criar uma promessa pendente\n            CanalVideosComponent._pending_requests[self.instance_id] = asyncio.get_event_loop().create_future()\n            \n            # Preparar a URL e headers\n            url = f\"{supabase_url}/rest/v1/rpc/obter_canal_e_videos\"\n            headers = {\n                \"Content-Type\": \"application/json\",\n                \"apikey\": supabase_key,\n                \"Authorization\": f\"Bearer {supabase_key}\"\n            }\n            \n            # Preparar os dados\n            data = {\"canal_id\": canal_id_value}\n            \n            # Fazer a chamada HTTP\n            async with httpx.AsyncClient() as client:\n                response = await client.post(url, json=data, headers=headers)\n                response.raise_for_status()\n                result = response.json()\n                \n                logger.debug(f\"Resposta da API: {result}\")\n                \n                # Processa o resultado baseado na resposta real\n                # Estrutura esperada: {'youtube_channel_id': 'ID_DO_CANAL', 'video_id': 'ID_DO_VIDEO'} ou lista de dicionários\n                result_data = {\n                    \"tabela_canal_id\": canal_id_str  # Armazenar o ID da tabela canal na resposta\n                }\n                \n                if isinstance(result, dict):\n                    # Caso único resultado\n                    canal_id = result.get(\"youtube_channel_id\", \"\")\n                    \n                    # Verifica se temos video_id ou videos\n                    if \"video_id\" in result:\n                        # Caso único vídeo\n                        videos_str = str(result.get(\"video_id\", \"\"))\n                    elif \"videos\" in result:\n                        # Caso lista de vídeos\n                        videos = result.get(\"videos\", [])\n                        if isinstance(videos, list):\n                            videos_str = \",\".join([str(v) for v in videos])\n                        else:\n                            videos_str = str(videos)\n                    else:\n                        videos_str = \"\"\n                        \n                    result_data.update({\n                        \"canal_id\": str(canal_id),\n                        \"videos\": videos_str\n                    })\n                elif isinstance(result, list):\n                    # Caso lista de resultados\n                    # Extrair o ID do canal do primeiro item (assumindo que todos têm o mesmo canal_id)\n                    canal_id = \"\"\n                    videos = []\n                    \n                    for item in result:\n                        if isinstance(item, dict):\n                            # Se ainda não temos canal_id, pegamos do primeiro item\n                            if not canal_id and \"youtube_channel_id\" in item:\n                                canal_id = item.get(\"youtube_channel_id\", \"\")\n                                \n                            # Adicionar video_id à lista\n                            if \"video_id\" in item:\n                                videos.append(str(item.get(\"video_id\", \"\")))\n                    \n                    result_data.update({\n                        \"canal_id\": str(canal_id),\n                        \"videos\": \",\".join(videos)\n                    })\n                \n                # Armazenar os dados no cache estático\n                CanalVideosComponent._data_cache[self.instance_id] = result_data\n                \n                # Resolver a promessa pendente\n                if not CanalVideosComponent._pending_requests[self.instance_id].done():\n                    CanalVideosComponent._pending_requests[self.instance_id].set_result(True)\n                \n                logger.debug(f\"Dados obtidos com sucesso: {result_data}\")\n                return result_data\n        \n        except Exception as e:\n            error_msg = f\"Erro ao obter dados do canal e vídeos: {str(e)}\"\n            logger.error(error_msg)\n            \n            # Ainda armazenar o ID da tabela canal mesmo em caso de erro\n            canal_id_str = self._process_input(self.canal_tabela_id)\n            CanalVideosComponent._data_cache[self.instance_id] = {\n                \"error\": error_msg,\n                \"tabela_canal_id\": canal_id_str\n            }\n            \n            # Resolver a promessa com erro\n            if self.instance_id in CanalVideosComponent._pending_requests and \\\n               CanalVideosComponent._pending_requests[self.instance_id] and \\\n               not CanalVideosComponent._pending_requests[self.instance_id].done():\n                CanalVideosComponent._pending_requests[self.instance_id].set_exception(e)\n                \n            return {\"error\": error_msg, \"tabela_canal_id\": canal_id_str}\n    \n    def _sync_ensure_data_loaded(self):\n        \"\"\"Versão síncrona para garantir que os dados estejam carregados.\"\"\"\n        if not self._get_data() and hasattr(self, 'canal_tabela_id') and self.canal_tabela_id:\n            try:\n                asyncio.run(self._ensure_data_loaded())\n            except RuntimeError:\n                # Pode ocorrer \"RuntimeError: There is no current event loop in thread\"\n                # Neste caso, tentamos criar um novo loop\n                loop = asyncio.new_event_loop()\n                asyncio.set_event_loop(loop)\n                loop.run_until_complete(self._ensure_data_loaded())\n                loop.close()\n    \n    async def _ensure_data_loaded(self):\n        \"\"\"Garante que os dados estejam carregados antes de acessá-los.\"\"\"\n        if not self._get_data() and hasattr(self, 'canal_tabela_id') and self.canal_tabela_id:\n            # Se houver uma requisição pendente, aguarde sua conclusão\n            if (self.instance_id in CanalVideosComponent._pending_requests and \n                CanalVideosComponent._pending_requests[self.instance_id] is not None):\n                try:\n                    await CanalVideosComponent._pending_requests[self.instance_id]\n                except Exception:\n                    # Se houver uma exceção, apenas continue - o erro já foi registrado\n                    pass\n            else:\n                # Se não houver requisição pendente, faça uma nova\n                await self.obter_canal_e_videos()\n    \n    def _get_data(self):\n        \"\"\"Recupera os dados atuais do cache.\"\"\"\n        return CanalVideosComponent._data_cache.get(self.instance_id, {})\n    \n    # Métodos de saída compatíveis com Message\n    \n    def get_canal_id(self) -> Message:\n        \"\"\"Retorna o ID do canal do YouTube como mensagem.\"\"\"\n        self._sync_ensure_data_loaded()\n        data = self._get_data()\n        return Message(text=str(data.get(\"canal_id\", \"\")))\n    \n    def get_video_ids(self) -> Message:\n        \"\"\"Retorna os IDs dos vídeos do canal como mensagem de texto.\"\"\"\n        self._sync_ensure_data_loaded()\n        data = self._get_data()\n        return Message(text=str(data.get(\"videos\", \"\")))\n    \n    def get_tabela_canal_id(self) -> Message:\n        \"\"\"Retorna o ID da tabela canal de entrada como mensagem de texto.\"\"\"\n        # Se já temos dados carregados, pegar do cache\n        data = self._get_data()\n        if data and \"tabela_canal_id\" in data:\n            return Message(text=str(data.get(\"tabela_canal_id\", \"\")))\n        \n        # Se não, pegar diretamente do input\n        if hasattr(self, 'canal_tabela_id'):\n            canal_id_str = self._process_input(self.canal_tabela_id)\n            return Message(text=canal_id_str)\n        \n        return Message(text=\"\")\n    \n    def get_tabela_canal_id_2(self) -> Message:\n        \"\"\"Retorna o ID da tabela canal de entrada como mensagem de texto (segunda saída).\"\"\"\n        # Usa o mesmo método da primeira saída\n        return self.get_tabela_canal_id()\n    \n    def get_tabela_canal_id_3(self) -> Message:\n        \"\"\"Retorna o ID da tabela canal de entrada como mensagem de texto (terceira saída).\"\"\"\n        # Usa o mesmo método da primeira saída\n        return self.get_tabela_canal_id()"
              },
              "supabase_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Supabase Key",
                "dynamic": false,
                "info": "Chave de API do Supabase",
                "input_types": [],
                "load_from_db": true,
                "name": "supabase_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "Supabase Key Role"
              },
              "supabase_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Supabase URL",
                "dynamic": false,
                "info": "URL base do Supabase",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "supabase_url",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "https://suqjifkhmekcdflwowiw.supabase.co"
              }
            },
            "tool_mode": false
          },
          "selected_output": "youtube_canal_id",
          "showNode": true,
          "type": "CanalVideosComponent"
        },
        "dragging": false,
        "id": "CanalVideosComponent-KJuP3",
        "measured": {
          "height": 385,
          "width": 320
        },
        "position": {
          "x": 635.5284073621848,
          "y": 249.30372127523248
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "YouTubeVideoDetailsWithTranscript-ZrYJE",
          "node": {
            "base_classes": [
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Obtém detalhes e transcrições de múltiplos vídeos do YouTube (IDs separados por vírgula).",
            "display_name": "YouTube Video Details com Transcrição",
            "documentation": "",
            "edited": true,
            "field_order": [
              "video_ids",
              "api_key",
              "include_transcript",
              "max_timestamp",
              "timestamp_format",
              "include_statistics",
              "include_content_details",
              "include_tags",
              "include_thumbnails",
              "debug_mode"
            ],
            "frozen": false,
            "icon": "YouTube",
            "legacy": false,
            "lf_version": "1.5.0.post1",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Dados dos Vídeos",
                "hidden": false,
                "method": "get_videos_details_with_transcript",
                "name": "video_data",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "YouTube API Key",
                "dynamic": false,
                "info": "Sua chave da API de Dados do YouTube.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "Youtube"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from contextlib import contextmanager\nimport requests\nimport googleapiclient\nimport pandas as pd\nimport re\nfrom datetime import datetime, timedelta\n\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, MessageTextInput, SecretStrInput, IntInput, DropdownInput\nfrom langflow.schema import DataFrame\nfrom langflow.template import Output\n\n\nclass YouTubeVideoDetailsWithTranscript(Component):\n    \"\"\"Componente que obtém detalhes e transcrições de múltiplos vídeos do YouTube.\"\"\"\n\n    display_name: str = \"YouTube Video Details com Transcrição\"\n    description: str = \"Obtém detalhes e transcrições de múltiplos vídeos do YouTube (IDs separados por vírgula).\"\n    icon: str = \"YouTube\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"video_ids\",\n            display_name=\"IDs ou URLs dos Vídeos\",\n            info=\"IDs ou URLs de vídeos do YouTube separados por vírgula.\",\n            tool_mode=True,\n            required=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"YouTube API Key\",\n            info=\"Sua chave da API de Dados do YouTube.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"include_transcript\",\n            display_name=\"Incluir Transcrição\",\n            value=True,\n            info=\"Incluir transcrição do vídeo obtida via API.\",\n        ),\n        IntInput(\n            name=\"max_timestamp\",\n            display_name=\"Timestamp Máximo (minutos)\",\n            info=\"Tempo máximo da transcrição em minutos (0 = sem limite).\",\n            value=0,\n            # Removido de advanced para maior visibilidade\n        ),\n        DropdownInput(\n            name=\"timestamp_format\",\n            display_name=\"Formato de Timestamp\",\n            options=[\"incluir\", \"excluir\", \"apenas_texto\"],\n            value=\"incluir\",\n            info=\"Como tratar os timestamps na transcrição: incluir, excluir ou retornar apenas o texto.\",\n            # Removido de advanced para maior visibilidade\n        ),\n        BoolInput(\n            name=\"include_statistics\",\n            display_name=\"Incluir Estatísticas\",\n            value=True,\n            info=\"Incluir estatísticas do vídeo (visualizações, likes, comentários).\",\n        ),\n        BoolInput(\n            name=\"include_content_details\",\n            display_name=\"Incluir Detalhes de Conteúdo\",\n            value=True,\n            info=\"Incluir duração, qualidade e informações de restrição de idade.\",\n        ),\n        BoolInput(\n            name=\"include_tags\",\n            display_name=\"Incluir Tags\",\n            value=True,\n            info=\"Incluir tags e palavras-chave do vídeo.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"include_thumbnails\",\n            display_name=\"Incluir Miniaturas\",\n            value=True,\n            info=\"Incluir URLs de miniaturas em diferentes resoluções.\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"debug_mode\",\n            display_name=\"Modo Debug\",\n            value=False,\n            info=\"Ativar logs de depuração.\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"video_data\", display_name=\"Dados dos Vídeos\", method=\"get_videos_details_with_transcript\"),\n    ]\n\n    API_FORBIDDEN = 403\n    VIDEO_NOT_FOUND = 404\n    MAX_VIDEOS_PER_REQUEST = 50  # API limit for videos per request\n\n    @contextmanager\n    def youtube_client(self):\n        \"\"\"Context manager for YouTube API client.\"\"\"\n        client = build(\"youtube\", \"v3\", developerKey=self.api_key)\n        try:\n            yield client\n        finally:\n            client.close()\n\n    def _extract_video_ids(self, video_ids_or_urls: str) -> list:\n        \"\"\"Extracts multiple video IDs from URLs or direct IDs.\"\"\"\n        import re\n\n        # Split the input by commas\n        items = [item.strip() for item in video_ids_or_urls.split(',') if item.strip()]\n        \n        # Patterns for extracting video IDs from URLs\n        patterns = [\n            r\"(?:youtube\\.com\\/watch\\?v=|youtu.be\\/|youtube.com\\/embed\\/)([^&\\n?#]+)\",\n            r\"youtube.com\\/shorts\\/([^&\\n?#]+)\",\n        ]\n        \n        video_ids = []\n        \n        for item in items:\n            # Try to match URL patterns\n            matched = False\n            for pattern in patterns:\n                match = re.search(pattern, item)\n                if match:\n                    video_ids.append(match.group(1))\n                    matched = True\n                    break\n            \n            # If not matched as URL, assume it's a direct video ID\n            if not matched:\n                video_ids.append(item.strip())\n        \n        self._log_debug(f\"Extracted {len(video_ids)} video IDs: {video_ids}\")\n        return video_ids\n\n    def _format_duration(self, duration: str) -> str:\n        \"\"\"Formats the ISO 8601 duration to a readable format.\"\"\"\n        import re\n\n        try:\n            hours = 0\n            minutes = 0\n            seconds = 0\n\n            hours_match = re.search(r\"(\\d+)H\", duration)\n            minutes_match = re.search(r\"(\\d+)M\", duration)\n            seconds_match = re.search(r\"(\\d+)S\", duration)\n\n            if hours_match:\n                hours = int(hours_match.group(1))\n            if minutes_match:\n                minutes = int(minutes_match.group(1))\n            if seconds_match:\n                seconds = int(seconds_match.group(1))\n\n            if hours > 0:\n                return f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            return f\"{minutes:02d}:{seconds:02d}\"\n        except Exception as e:\n            self._log_debug(f\"Error formatting duration '{duration}': {str(e)}\")\n            return duration\n    \n    def _log_debug(self, message: str) -> None:\n        \"\"\"Logs debug messages if debug mode is activated.\"\"\"\n        if hasattr(self, 'debug_mode') and self.debug_mode:\n            print(f\"[DEBUG] {message}\")\n    \n    def _get_transcript_from_api(self, video_id: str) -> dict:\n        \"\"\"Obtains transcript using existing API.\"\"\"\n        result = {\n            \"success\": False,\n            \"transcript\": \"\",\n            \"error\": None\n        }\n        \n        try:\n            # Ensure we have a complete URL\n            video_url = f\"https://www.youtube.com/watch?v={video_id}\"\n            \n            self._log_debug(f\"Sending request to API for video: {video_id}\")\n            \n            # Make the request to the API\n            response = requests.post(\n                'https://youtube-transcribe.fly.dev/transcribe',\n                json={\"url\": video_url},\n                headers={'Content-Type': 'application/json'},\n                timeout=300  # 5 minutes\n            )\n            \n            # Check if the request was successful\n            if response.status_code == 200:\n                data = response.json()\n                \n                if 'transcription' in data and data['transcription']:\n                    result[\"transcript\"] = data['transcription']\n                    result[\"success\"] = True\n                    self._log_debug(f\"Transcript successfully obtained for video {video_id}\")\n                else:\n                    result[\"error\"] = \"API returned an empty response for the transcript\"\n                    self._log_debug(f\"Error for video {video_id}: {result['error']}\")\n            else:\n                result[\"error\"] = f\"API request error: {response.status_code} - {response.text}\"\n                self._log_debug(f\"Error for video {video_id}: {result['error']}\")\n                \n        except Exception as e:\n            result[\"error\"] = str(e)\n            self._log_debug(f\"Error obtaining transcript for video {video_id}: {str(e)}\")\n        \n        return result\n    \n    def _truncate_transcript_by_timestamp(self, transcript: str, max_minutes: int, timestamp_format: str) -> str:\n        \"\"\"Truncates transcript by maximum timestamp specified in minutes.\"\"\"\n        if not max_minutes or max_minutes <= 0:\n            # If max_minutes is 0 or negative, don't truncate\n            self._log_debug(\"No timestamp truncation (value 0 or negative)\")\n            \n            # We still apply timestamp formatting if requested\n            if timestamp_format == \"excluir\":\n                # Remove timestamps but keep text\n                return re.sub(r'\\[\\d{2}:\\d{2}:\\d{2}\\]\\s*', '', transcript)\n            elif timestamp_format == \"apenas_texto\":\n                # Remove timestamps and join all text without line breaks\n                cleaned_text = re.sub(r'\\[\\d{2}:\\d{2}:\\d{2}\\]\\s*', '', transcript)\n                return ' '.join(cleaned_text.split())\n            else:\n                # Keep original format\n                return transcript\n        \n        self._log_debug(f\"Truncating transcript at {max_minutes} minutes\")\n        \n        # Convert minutes to seconds for easier comparison\n        max_seconds = max_minutes * 60\n        \n        # Regex to extract timestamps in [HH:MM:SS] format\n        timestamp_pattern = r'\\[(\\d{2}):(\\d{2}):(\\d{2})\\]'\n        \n        lines = transcript.split('\\n')\n        truncated_lines = []\n        \n        for line in lines:\n            match = re.search(timestamp_pattern, line)\n            if match:\n                hours, minutes, seconds = map(int, match.groups())\n                total_seconds = hours * 3600 + minutes * 60 + seconds\n                \n                if total_seconds <= max_seconds:\n                    truncated_lines.append(line)\n                else:\n                    # Found a line that exceeds the time limit\n                    self._log_debug(f\"Truncation at: {hours:02d}:{minutes:02d}:{seconds:02d}\")\n                    break\n            else:\n                # Lines without timestamp (like headers) are kept if they are before the truncation point\n                if truncated_lines:  # Only add if we already have valid lines\n                    truncated_lines.append(line)\n        \n        # Apply requested timestamp formatting\n        truncated_transcript = '\\n'.join(truncated_lines)\n        \n        if timestamp_format == \"excluir\":\n            # Remove timestamps but keep text with line breaks\n            return re.sub(r'\\[\\d{2}:\\d{2}:\\d{2}\\]\\s*', '', truncated_transcript)\n        elif timestamp_format == \"apenas_texto\":\n            # Remove timestamps and join all text without line breaks\n            cleaned_text = re.sub(r'\\[\\d{2}:\\d{2}:\\d{2}\\]\\s*', '', truncated_transcript)\n            return ' '.join(cleaned_text.split())\n        else:\n            # Keep original format with timestamps\n            return truncated_transcript\n\n    def get_videos_details_with_transcript(self) -> DataFrame:\n        \"\"\"Retrieves detailed information and transcripts for multiple YouTube videos.\"\"\"\n        try:\n            # Extract video IDs\n            video_ids = self._extract_video_ids(self.video_ids)\n            \n            if not video_ids:\n                return DataFrame(pd.DataFrame({\"error\": [\"No valid video IDs provided\"]}))\n            \n            # Prepare parts for the API request\n            parts = [\"snippet\"]\n            if self.include_statistics:\n                parts.append(\"statistics\")\n            if self.include_content_details:\n                parts.append(\"contentDetails\")\n            \n            parts_str = \",\".join(parts)\n            self._log_debug(f\"Requesting parts: {parts_str}\")\n            \n            all_videos_data = []\n            \n            with self.youtube_client() as youtube:\n                # Process videos in batches to respect API limits\n                for i in range(0, len(video_ids), self.MAX_VIDEOS_PER_REQUEST):\n                    batch = video_ids[i:i + self.MAX_VIDEOS_PER_REQUEST]\n                    batch_ids = \",\".join(batch)\n                    \n                    self._log_debug(f\"Processing batch of {len(batch)} videos\")\n                    \n                    try:\n                        # Get video information for this batch\n                        video_response = youtube.videos().list(part=parts_str, id=batch_ids).execute()\n                        \n                        # Process each video in the response\n                        for video_info in video_response.get(\"items\", []):\n                            try:\n                                video_id = video_info.get(\"id\", \"\")\n                                \n                                # Skip if missing critical info\n                                if not video_id or \"snippet\" not in video_info:\n                                    self._log_debug(f\"Skipping video with missing data: {video_id}\")\n                                    continue\n                                \n                                snippet = video_info[\"snippet\"]\n                                \n                                # Build video data dictionary\n                                video_data = {\n                                    \"video_id\": video_id,\n                                    \"url\": f\"https://www.youtube.com/watch?v={video_id}\",\n                                    \"title\": snippet.get(\"title\", \"\"),\n                                    \"description\": snippet.get(\"description\", \"\"),\n                                    \"published_at\": snippet.get(\"publishedAt\", \"\"),\n                                    \"channel_id\": snippet.get(\"channelId\", \"\"),\n                                    \"channel_title\": snippet.get(\"channelTitle\", \"\"),\n                                    \"category_id\": snippet.get(\"categoryId\", \"Unknown\"),\n                                    \"live_broadcast_content\": snippet.get(\"liveBroadcastContent\", \"none\"),\n                                }\n                                \n                                # Add thumbnails if requested\n                                if self.include_thumbnails and \"thumbnails\" in snippet:\n                                    for size, thumb in snippet[\"thumbnails\"].items():\n                                        video_data[f\"thumbnail_{size}_url\"] = thumb.get(\"url\", \"\")\n                                        video_data[f\"thumbnail_{size}_width\"] = thumb.get(\"width\", 0)\n                                        video_data[f\"thumbnail_{size}_height\"] = thumb.get(\"height\", 0)\n                                \n                                # Add tags if requested\n                                if self.include_tags and \"tags\" in snippet:\n                                    video_data[\"tags\"] = \", \".join(snippet[\"tags\"])\n                                    video_data[\"tags_count\"] = len(snippet[\"tags\"])\n                                \n                                # Add statistics if requested\n                                if self.include_statistics and \"statistics\" in video_info:\n                                    stats = video_info[\"statistics\"]\n                                    video_data.update({\n                                        \"view_count\": int(stats.get(\"viewCount\", 0)),\n                                        \"like_count\": int(stats.get(\"likeCount\", 0)),\n                                        \"favorite_count\": int(stats.get(\"favoriteCount\", 0)),\n                                        \"comment_count\": int(stats.get(\"commentCount\", 0)),\n                                    })\n                                \n                                # Add content details if requested\n                                if self.include_content_details and \"contentDetails\" in video_info:\n                                    content_details = video_info[\"contentDetails\"]\n                                    video_data.update({\n                                        \"duration\": self._format_duration(content_details.get(\"duration\", \"\")),\n                                        \"dimension\": content_details.get(\"dimension\", \"2d\"),\n                                        \"definition\": content_details.get(\"definition\", \"hd\").upper(),\n                                        \"has_captions\": content_details.get(\"caption\", \"false\") == \"true\",\n                                        \"licensed_content\": content_details.get(\"licensedContent\", False),\n                                        \"projection\": content_details.get(\"projection\", \"rectangular\"),\n                                        \"has_custom_thumbnails\": content_details.get(\"hasCustomThumbnail\", False),\n                                    })\n                                    \n                                    # Add content rating if available\n                                    if \"contentRating\" in content_details:\n                                        rating_info = content_details[\"contentRating\"]\n                                        video_data[\"content_rating\"] = str(rating_info)\n                                \n                                # Add transcript if requested\n                                if self.include_transcript:\n                                    self._log_debug(f\"Getting transcript for video ID: {video_id}\")\n                                    transcript_result = self._get_transcript_from_api(video_id)\n                                    \n                                    if transcript_result[\"success\"]:\n                                        # Apply timestamp truncation if necessary\n                                        max_timestamp = getattr(self, 'max_timestamp', 0)\n                                        timestamp_format = getattr(self, 'timestamp_format', 'incluir')\n                                        \n                                        truncated_transcript = self._truncate_transcript_by_timestamp(\n                                            transcript_result[\"transcript\"],\n                                            max_timestamp,\n                                            timestamp_format\n                                        )\n                                        \n                                        video_data[\"transcript\"] = truncated_transcript\n                                        video_data[\"transcript_success\"] = True\n                                        video_data[\"transcript_truncated\"] = max_timestamp > 0\n                                        # Adicionar informação sobre o timestamp máximo usado\n                                        video_data[\"transcript_max_minutes\"] = max_timestamp\n                                    else:\n                                        video_data[\"transcript\"] = \"\"\n                                        video_data[\"transcript_success\"] = False\n                                        video_data[\"transcript_error\"] = transcript_result[\"error\"]\n                                \n                                all_videos_data.append(video_data)\n                            except Exception as e:\n                                self._log_debug(f\"Error processing video {video_info.get('id', 'unknown')}: {str(e)}\")\n                                continue\n                    \n                    except HttpError as e:\n                        self._log_debug(f\"Error in batch request: {str(e)}\")\n                        # Continue with other batches even if one fails\n            \n            # Return error if no videos were processed successfully\n            if not all_videos_data:\n                return DataFrame(pd.DataFrame({\"error\": [\"No videos could be processed successfully\"]}))\n            \n            # Create DataFrame with organized columns\n            video_df = pd.DataFrame(all_videos_data)\n            \n            # Organize columns in logical groups\n            basic_cols = [\n                \"video_id\",\n                \"title\",\n                \"url\",\n                \"channel_id\",\n                \"channel_title\",\n                \"published_at\",\n                \"category_id\",\n                \"live_broadcast_content\",\n                \"description\",\n            ]\n            \n            stat_cols = [\"view_count\", \"like_count\", \"favorite_count\", \"comment_count\"]\n            \n            content_cols = [\n                \"duration\",\n                \"dimension\",\n                \"definition\",\n                \"has_captions\",\n                \"licensed_content\",\n                \"projection\",\n                \"has_custom_thumbnails\",\n                \"content_rating\",\n            ]\n            \n            tag_cols = [\"tags\", \"tags_count\"]\n            \n            thumb_cols = [col for col in video_df.columns if col.startswith(\"thumbnail_\")]\n            \n            transcript_cols = [\n                \"transcript\", \n                \"transcript_success\", \n                \"transcript_error\", \n                \"transcript_truncated\",\n                \"transcript_max_minutes\"\n            ]\n            \n            # Reorder columns based on what's included\n            ordered_cols = basic_cols.copy()\n            \n            if self.include_statistics:\n                ordered_cols.extend([col for col in stat_cols if col in video_df.columns])\n            \n            if self.include_content_details:\n                ordered_cols.extend([col for col in content_cols if col in video_df.columns])\n            \n            if self.include_tags:\n                ordered_cols.extend([col for col in tag_cols if col in video_df.columns])\n            \n            if self.include_thumbnails:\n                ordered_cols.extend(sorted(thumb_cols))\n            \n            if self.include_transcript:\n                ordered_cols.extend([col for col in transcript_cols if col in video_df.columns])\n            \n            # Add any remaining columns\n            remaining_cols = [col for col in video_df.columns if col not in ordered_cols]\n            ordered_cols.extend(remaining_cols)\n            \n            # Filter to only include columns that exist in the DataFrame\n            filtered_cols = [col for col in ordered_cols if col in video_df.columns]\n            \n            self._log_debug(f\"Successfully processed {len(all_videos_data)} videos\")\n            return DataFrame(video_df[filtered_cols])\n        \n        except (HttpError, googleapiclient.errors.HttpError) as e:\n            error_message = f\"YouTube API error: {e!s}\"\n            if hasattr(e, 'resp') and e.resp.status == self.API_FORBIDDEN:\n                error_message = \"API quota exceeded or access forbidden.\"\n            elif hasattr(e, 'resp') and e.resp.status == self.VIDEO_NOT_FOUND:\n                error_message = \"Videos not found.\"\n            \n            self._log_debug(f\"Error: {error_message}\")\n            return DataFrame(pd.DataFrame({\"error\": [error_message]}))\n        \n        except Exception as e:\n            error_message = f\"Error retrieving video details: {str(e)}\"\n            self._log_debug(f\"Unexpected error: {error_message}\")\n            return DataFrame(pd.DataFrame({\"error\": [error_message]}))"
              },
              "debug_mode": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Modo Debug",
                "dynamic": false,
                "info": "Ativar logs de depuração.",
                "list": false,
                "list_add_label": "Add More",
                "name": "debug_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "include_content_details": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Incluir Detalhes de Conteúdo",
                "dynamic": false,
                "info": "Incluir duração, qualidade e informações de restrição de idade.",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_content_details",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "include_statistics": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Incluir Estatísticas",
                "dynamic": false,
                "info": "Incluir estatísticas do vídeo (visualizações, likes, comentários).",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_statistics",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "include_tags": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Incluir Tags",
                "dynamic": false,
                "info": "Incluir tags e palavras-chave do vídeo.",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_tags",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "include_thumbnails": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Incluir Miniaturas",
                "dynamic": false,
                "info": "Incluir URLs de miniaturas em diferentes resoluções.",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_thumbnails",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "include_transcript": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Incluir Transcrição",
                "dynamic": false,
                "info": "Incluir transcrição do vídeo obtida via API.",
                "list": false,
                "list_add_label": "Add More",
                "name": "include_transcript",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "max_timestamp": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Timestamp Máximo (minutos)",
                "dynamic": false,
                "info": "Tempo máximo da transcrição em minutos (0 = sem limite).",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_timestamp",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 10
              },
              "timestamp_format": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Formato de Timestamp",
                "dynamic": false,
                "info": "Como tratar os timestamps na transcrição: incluir, excluir ou retornar apenas o texto.",
                "name": "timestamp_format",
                "options": [
                  "incluir",
                  "excluir",
                  "apenas_texto"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "incluir"
              },
              "video_ids": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "IDs ou URLs dos Vídeos",
                "dynamic": false,
                "info": "IDs ou URLs de vídeos do YouTube separados por vírgula.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "video_ids",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "YouTubeVideoDetailsWithTranscript"
        },
        "dragging": false,
        "id": "YouTubeVideoDetailsWithTranscript-ZrYJE",
        "measured": {
          "height": 595,
          "width": 320
        },
        "position": {
          "x": 2121.5644107464013,
          "y": -987.4767377318417
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-tGP7L",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "hidden": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "id do video: {video_id},\nTitulo: {title}\nDescricao: {description}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-tGP7L",
        "measured": {
          "height": 329,
          "width": 320
        },
        "position": {
          "x": 2473.8008232577363,
          "y": -744.6323586514652
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "AnthropicModel-SqDHi",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate text using Anthropic Chat&Completion LLMs with prefill support.",
            "display_name": "Anthropic",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_tokens",
              "model_name",
              "api_key",
              "temperature",
              "base_url",
              "tool_model_enabled",
              "prefill"
            ],
            "frozen": false,
            "icon": "Anthropic",
            "last_updated": "2025-10-19T06:19:15.225Z",
            "legacy": false,
            "metadata": {
              "keywords": [
                "model",
                "llm",
                "language model",
                "large language model"
              ]
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Model Response",
                "group_outputs": false,
                "hidden": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "group_outputs": false,
                "hidden": null,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": null,
                "selected": "LanguageModel",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Anthropic API Key",
                "dynamic": false,
                "info": "Your Anthropic API key.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "real_time_refresh": true,
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "Anthropic"
              },
              "base_url": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Anthropic API URL",
                "dynamic": false,
                "info": "Endpoint of the Anthropic API. Defaults to 'https://api.anthropic.com' if not specified.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "base_url",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "https://api.anthropic.com"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any, cast\n\nimport requests\nfrom loguru import logger\nfrom pydantic import ValidationError\n\nfrom langflow.base.models.anthropic_constants import (\n    ANTHROPIC_MODELS,\n    DEFAULT_ANTHROPIC_API_URL,\n    TOOL_CALLING_SUPPORTED_ANTHROPIC_MODELS,\n    TOOL_CALLING_UNSUPPORTED_ANTHROPIC_MODELS,\n)\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, SecretStrInput, SliderInput\nfrom langflow.schema.dotdict import dotdict\n\n\nclass AnthropicModelComponent(LCModelComponent):\n    display_name = \"Anthropic\"\n    description = \"Generate text using Anthropic Chat&Completion LLMs with prefill support.\"\n    icon = \"Anthropic\"\n    name = \"AnthropicModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            value=4096,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            options=ANTHROPIC_MODELS,\n            refresh_button=True,\n            value=ANTHROPIC_MODELS[0],\n            combobox=True,\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"Anthropic API Key\",\n            info=\"Your Anthropic API key.\",\n            value=None,\n            required=True,\n            real_time_refresh=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            info=\"Run inference with this temperature. Must by in the closed interval [0.0, 1.0].\",\n            range_spec=RangeSpec(min=0, max=1, step=0.01),\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"base_url\",\n            display_name=\"Anthropic API URL\",\n            info=\"Endpoint of the Anthropic API. Defaults to 'https://api.anthropic.com' if not specified.\",\n            value=DEFAULT_ANTHROPIC_API_URL,\n            real_time_refresh=True,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"tool_model_enabled\",\n            display_name=\"Enable Tool Models\",\n            info=(\n                \"Select if you want to use models that can work with tools. If yes, only those models will be shown.\"\n            ),\n            advanced=False,\n            value=False,\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"prefill\", display_name=\"Prefill\", info=\"Prefill text to guide the model's response.\", advanced=True\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_anthropic.chat_models import ChatAnthropic\n        except ImportError as e:\n            msg = \"langchain_anthropic is not installed. Please install it with `pip install langchain_anthropic`.\"\n            raise ImportError(msg) from e\n        try:\n            max_tokens_value = getattr(self, \"max_tokens\", \"\")\n            max_tokens_value = 4096 if max_tokens_value == \"\" else int(max_tokens_value)\n            output = ChatAnthropic(\n                model=self.model_name,\n                anthropic_api_key=self.api_key,\n                max_tokens=max_tokens_value,\n                temperature=self.temperature,\n                anthropic_api_url=self.base_url or DEFAULT_ANTHROPIC_API_URL,\n                streaming=self.stream,\n            )\n        except ValidationError:\n            raise\n        except Exception as e:\n            msg = \"Could not connect to Anthropic API.\"\n            raise ValueError(msg) from e\n\n        return output\n\n    def get_models(self, tool_model_enabled: bool | None = None) -> list[str]:\n        try:\n            import anthropic\n\n            client = anthropic.Anthropic(api_key=self.api_key)\n            models = client.models.list(limit=20).data\n            model_ids = ANTHROPIC_MODELS + [model.id for model in models]\n        except (ImportError, ValueError, requests.exceptions.RequestException) as e:\n            logger.exception(f\"Error getting model names: {e}\")\n            model_ids = ANTHROPIC_MODELS\n\n        if tool_model_enabled:\n            try:\n                from langchain_anthropic.chat_models import ChatAnthropic\n            except ImportError as e:\n                msg = \"langchain_anthropic is not installed. Please install it with `pip install langchain_anthropic`.\"\n                raise ImportError(msg) from e\n\n            # Create a new list instead of modifying while iterating\n            filtered_models = []\n            for model in model_ids:\n                if model in TOOL_CALLING_SUPPORTED_ANTHROPIC_MODELS:\n                    filtered_models.append(model)\n                    continue\n\n                model_with_tool = ChatAnthropic(\n                    model=model,  # Use the current model being checked\n                    anthropic_api_key=self.api_key,\n                    anthropic_api_url=cast(str, self.base_url) or DEFAULT_ANTHROPIC_API_URL,\n                )\n\n                if (\n                    not self.supports_tool_calling(model_with_tool)\n                    or model in TOOL_CALLING_UNSUPPORTED_ANTHROPIC_MODELS\n                ):\n                    continue\n\n                filtered_models.append(model)\n\n            return filtered_models\n\n        return model_ids\n\n    def _get_exception_message(self, exception: Exception) -> str | None:\n        \"\"\"Get a message from an Anthropic exception.\n\n        Args:\n            exception (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from anthropic import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(exception, BadRequestError):\n            message = exception.body.get(\"error\", {}).get(\"message\")\n            if message:\n                return message\n        return None\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if \"base_url\" in build_config and build_config[\"base_url\"][\"value\"] is None:\n            build_config[\"base_url\"][\"value\"] = DEFAULT_ANTHROPIC_API_URL\n            self.base_url = DEFAULT_ANTHROPIC_API_URL\n        if field_name in {\"base_url\", \"model_name\", \"tool_model_enabled\", \"api_key\"} and field_value:\n            try:\n                if len(self.api_key) == 0:\n                    ids = ANTHROPIC_MODELS\n                else:\n                    try:\n                        ids = self.get_models(tool_model_enabled=self.tool_model_enabled)\n                    except (ImportError, ValueError, requests.exceptions.RequestException) as e:\n                        logger.exception(f\"Error getting model names: {e}\")\n                        ids = ANTHROPIC_MODELS\n                build_config[\"model_name\"][\"options\"] = ids\n                build_config[\"model_name\"][\"value\"] = ids[0]\n                build_config[\"model_name\"][\"combobox\"] = True\n            except Exception as e:\n                msg = f\"Error getting model names: {e}\"\n                raise ValueError(msg) from e\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 4096
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "info": "",
                "load_from_db": false,
                "name": "model_name",
                "options": [
                  "claude-opus-4-20250514",
                  "claude-sonnet-4-20250514",
                  "claude-3-7-sonnet-latest",
                  "claude-3-5-sonnet-latest",
                  "claude-3-5-haiku-latest",
                  "claude-3-opus-latest",
                  "claude-3-sonnet-20240229",
                  "claude-haiku-4-5-20251001",
                  "claude-sonnet-4-5-20250929",
                  "claude-opus-4-1-20250805",
                  "claude-opus-4-20250514",
                  "claude-sonnet-4-20250514",
                  "claude-3-7-sonnet-20250219",
                  "claude-3-5-sonnet-20241022",
                  "claude-3-5-haiku-20241022",
                  "claude-3-5-sonnet-20240620",
                  "claude-3-haiku-20240307",
                  "claude-3-opus-20240229"
                ],
                "options_metadata": [],
                "placeholder": "",
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "claude-sonnet-4-5-20250929"
              },
              "prefill": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Prefill",
                "dynamic": false,
                "info": "Prefill text to guide the model's response.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "prefill",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Quantos videos Tem na entrada? Responda apenas quantos videos tiferentes tem"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": true,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "Run inference with this temperature. Must by in the closed interval [0.0, 1.0].",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 1,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "tool_model_enabled": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Enable Tool Models",
                "dynamic": false,
                "info": "Select if you want to use models that can work with tools. If yes, only those models will be shown.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_model_enabled",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              }
            },
            "tool_mode": false
          },
          "selected_output": "text_output",
          "showNode": true,
          "type": "AnthropicModel"
        },
        "dragging": false,
        "id": "AnthropicModel-SqDHi",
        "measured": {
          "height": 510,
          "width": 320
        },
        "position": {
          "x": 2903.6254430768345,
          "y": -503.11398844556703
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ProjetoDadosComponent-Rcjqu",
          "node": {
            "base_classes": [
              "DataFrame",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Recupera dados de projetos associados a um canal específico",
            "display_name": "Dados de Projeto por Canal",
            "documentation": "",
            "edited": true,
            "field_order": [
              "canal_id",
              "supabase_url",
              "supabase_key"
            ],
            "frozen": false,
            "icon": "Database",
            "legacy": false,
            "lf_version": "1.5.0.post1",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Dados do Projeto",
                "hidden": null,
                "method": "get_projeto_dados",
                "name": "projeto_dados",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Nome do Produto/Serviço",
                "hidden": false,
                "method": "get_nome_produto",
                "name": "nome_produto",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Descrição do Serviço",
                "hidden": false,
                "method": "get_descricao_servico",
                "name": "descricao_servico",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "País",
                "hidden": null,
                "method": "get_pais",
                "name": "pais",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "canal_id": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "ID do Canal",
                "dynamic": false,
                "info": "ID do canal para buscar os dados do projeto",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "canal_id",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.inputs import MessageTextInput, SecretStrInput\nfrom langflow.template import Output\nfrom langflow.schema import DataFrame\nfrom langflow.schema.message import Message\nimport pandas as pd\nfrom loguru import logger\nimport asyncio\nimport json\n\nclass ProjetoDadosComponent(Component):\n    display_name = \"Dados de Projeto por Canal\"\n    description = \"Recupera dados de projetos associados a um canal específico\"\n    icon = \"Database\"\n    name = \"ProjetoDadosComponent\"\n\n    # Cache para armazenar os dados recuperados\n    _data_cache = {}\n    # Controle de requisições pendentes\n    _pending_requests = {}\n\n    inputs = [\n        MessageTextInput(\n            name=\"canal_id\",\n            display_name=\"ID do Canal\",\n            info=\"ID do canal para buscar os dados do projeto\",\n            tool_mode=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"supabase_url\",\n            display_name=\"Supabase URL\",\n            value=\"https://suqjifkhmekcdflwowiw.supabase.co\",\n            info=\"URL base do Supabase\",\n            tool_mode=True,\n        ),\n        SecretStrInput(\n            name=\"supabase_key\",\n            display_name=\"Supabase Key\",\n            info=\"Chave de API do Supabase\",\n            required=True,\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"Dados do Projeto\", name=\"projeto_dados\", method=\"get_projeto_dados\"),\n        Output(display_name=\"Nome do Produto/Serviço\", name=\"nome_produto\", method=\"get_nome_produto\"),\n        Output(display_name=\"Descrição do Serviço\", name=\"descricao_servico\", method=\"get_descricao_servico\"),\n        Output(display_name=\"País\", name=\"pais\", method=\"get_pais\"),\n    ]\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Identificador único para este componente\n        self.instance_id = id(self)\n        # Garantir que este componente tenha uma entrada no cache\n        ProjetoDadosComponent._data_cache[self.instance_id] = {}\n        ProjetoDadosComponent._pending_requests[self.instance_id] = None\n\n    def _process_input(self, input_value):\n        \"\"\"Processa os valores de entrada para garantir compatibilidade.\"\"\"\n        if input_value is None:\n            return \"\"\n        if isinstance(input_value, Message):\n            return input_value.text or \"\"\n        if isinstance(input_value, dict) and \"text\" in input_value:\n            return input_value[\"text\"] or \"\"\n        return str(input_value)\n\n    async def obter_dados_projeto(self) -> dict:\n        \"\"\"Chama a função obter_dados_projeto_por_canal no Supabase e retorna os dados.\"\"\"\n        try:\n            import httpx\n            \n            canal_id_str = self._process_input(self.canal_id)\n            supabase_url = self._process_input(self.supabase_url)\n            supabase_key = self._process_input(self.supabase_key)\n            \n            # Validações básicas\n            if not canal_id_str.strip():\n                raise ValueError(\"ID do canal não pode ser vazio\")\n                \n            if not canal_id_str.strip().isdigit():\n                raise ValueError(f\"ID do canal deve ser numérico: {canal_id_str}\")\n                \n            canal_id_int = int(canal_id_str.strip())\n            \n            # Criar uma promessa pendente\n            ProjetoDadosComponent._pending_requests[self.instance_id] = asyncio.get_event_loop().create_future()\n            \n            # Preparar a URL e headers\n            url = f\"{supabase_url}/rest/v1/rpc/obter_dados_projeto_por_canal\"\n            headers = {\n                \"Content-Type\": \"application/json\",\n                \"apikey\": supabase_key,\n                \"Authorization\": f\"Bearer {supabase_key}\"\n            }\n            \n            # Preparar os dados - usando \"canal_id\" como nome do parâmetro conforme o exemplo\n            data = {\"canal_id\": canal_id_int}\n            \n            logger.debug(f\"Enviando requisição para: {url}\")\n            logger.debug(f\"Dados da requisição: {data}\")\n            \n            # Fazer a chamada HTTP\n            async with httpx.AsyncClient() as client:\n                response = await client.post(url, json=data, headers=headers)\n                response.raise_for_status()\n                result = response.json()\n                \n                logger.debug(f\"Resposta da API: {result}\")\n                \n                # Processar os dados do resultado\n                dados_projeto = {}\n                \n                if isinstance(result, list) and len(result) > 0:\n                    # Pegar o primeiro item se for uma lista\n                    dados_projeto = result[0]\n                elif isinstance(result, dict):\n                    # Usar diretamente se for um dicionário\n                    dados_projeto = result\n                \n                # Armazenar os dados no cache estático\n                ProjetoDadosComponent._data_cache[self.instance_id] = dados_projeto\n                \n                # Resolver a promessa pendente\n                if not ProjetoDadosComponent._pending_requests[self.instance_id].done():\n                    ProjetoDadosComponent._pending_requests[self.instance_id].set_result(True)\n                \n                logger.debug(f\"Dados obtidos com sucesso: {dados_projeto}\")\n                return dados_projeto\n        \n        except Exception as e:\n            error_msg = f\"Erro ao obter dados do projeto: {str(e)}\"\n            logger.error(error_msg)\n            \n            # Armazenar o erro no cache\n            ProjetoDadosComponent._data_cache[self.instance_id] = {\n                \"error\": error_msg,\n                \"canal_id\": canal_id_str\n            }\n            \n            # Resolver a promessa com erro\n            if self.instance_id in ProjetoDadosComponent._pending_requests and \\\n               ProjetoDadosComponent._pending_requests[self.instance_id] and \\\n               not ProjetoDadosComponent._pending_requests[self.instance_id].done():\n                ProjetoDadosComponent._pending_requests[self.instance_id].set_exception(e)\n                \n            return {\"error\": error_msg, \"canal_id\": canal_id_str}\n    \n    def _sync_ensure_data_loaded(self):\n        \"\"\"Versão síncrona para garantir que os dados estejam carregados.\"\"\"\n        if not self._get_data() and hasattr(self, 'canal_id') and self.canal_id:\n            try:\n                asyncio.run(self._ensure_data_loaded())\n            except RuntimeError:\n                # Pode ocorrer \"RuntimeError: There is no current event loop in thread\"\n                # Neste caso, tentamos criar um novo loop\n                loop = asyncio.new_event_loop()\n                asyncio.set_event_loop(loop)\n                loop.run_until_complete(self._ensure_data_loaded())\n                loop.close()\n    \n    async def _ensure_data_loaded(self):\n        \"\"\"Garante que os dados estejam carregados antes de acessá-los.\"\"\"\n        if not self._get_data() and hasattr(self, 'canal_id') and self.canal_id:\n            # Se houver uma requisição pendente, aguarde sua conclusão\n            if (self.instance_id in ProjetoDadosComponent._pending_requests and \n                ProjetoDadosComponent._pending_requests[self.instance_id] is not None):\n                try:\n                    await ProjetoDadosComponent._pending_requests[self.instance_id]\n                except Exception:\n                    # Se houver uma exceção, apenas continue - o erro já foi registrado\n                    pass\n            else:\n                # Se não houver requisição pendente, faça uma nova\n                await self.obter_dados_projeto()\n    \n    def _get_data(self):\n        \"\"\"Recupera os dados atuais do cache.\"\"\"\n        return ProjetoDadosComponent._data_cache.get(self.instance_id, {})\n    \n    # Métodos de saída compatíveis com Message\n    \n    def get_projeto_dados(self) -> DataFrame:\n        \"\"\"Retorna todos os dados do projeto como DataFrame.\"\"\"\n        self._sync_ensure_data_loaded()\n        data = self._get_data()\n        \n        if not data or \"error\" in data:\n            # Retornar DataFrame com erro se houver\n            error_msg = data.get(\"error\", \"Sem dados disponíveis\")\n            return DataFrame(pd.DataFrame({\"error\": [error_msg]}))\n        \n        # Converter para DataFrame\n        return DataFrame(pd.DataFrame([data]))\n    \n    def get_nome_produto(self) -> Message:\n        \"\"\"Retorna o nome do produto/serviço como mensagem.\"\"\"\n        self._sync_ensure_data_loaded()\n        data = self._get_data()\n        return Message(text=str(data.get(\"nome_produto_servico\", \"\")))\n    \n    def get_descricao_servico(self) -> Message:\n        \"\"\"Retorna a descrição do serviço como mensagem.\"\"\"\n        self._sync_ensure_data_loaded()\n        data = self._get_data()\n        return Message(text=str(data.get(\"descricao_servico\", \"\")))\n    \n    def get_pais(self) -> Message:\n        \"\"\"Retorna o país do projeto como mensagem.\"\"\"\n        self._sync_ensure_data_loaded()\n        data = self._get_data()\n        return Message(text=str(data.get(\"pais\", \"\")))"
              },
              "supabase_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Supabase Key",
                "dynamic": false,
                "info": "Chave de API do Supabase",
                "input_types": [],
                "load_from_db": true,
                "name": "supabase_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "Supabase Key Role"
              },
              "supabase_url": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Supabase URL",
                "dynamic": false,
                "info": "URL base do Supabase",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "supabase_url",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "https://suqjifkhmekcdflwowiw.supabase.co"
              }
            },
            "tool_mode": false
          },
          "selected_output": "projeto_dados",
          "showNode": true,
          "type": "ProjetoDadosComponent"
        },
        "dragging": false,
        "id": "ProjetoDadosComponent-Rcjqu",
        "measured": {
          "height": 385,
          "width": 320
        },
        "position": {
          "x": 1000.4631172517759,
          "y": 637.4208033697433
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "MultiPromptInput-l3Sqa",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Gerencia múltiplos prompts com saídas unificadas e individuais.",
            "display_name": "Multi Prompt Input",
            "documentation": "",
            "edited": true,
            "field_order": [
              "prompt1",
              "dynamic_prompt1",
              "prompt2",
              "dynamic_prompt2",
              "prompt3",
              "dynamic_prompt3",
              "prompt4",
              "dynamic_prompt4",
              "prompt5",
              "dynamic_prompt5",
              "prompt6",
              "dynamic_prompt6",
              "separator"
            ],
            "frozen": false,
            "icon": "message-square-text",
            "legacy": false,
            "lf_version": "1.5.0.post1",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Mensagem Unificada",
                "hidden": false,
                "method": "unified_response",
                "name": "unified_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt 1",
                "hidden": null,
                "method": "prompt1_response",
                "name": "prompt1_text",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt 2",
                "hidden": null,
                "method": "prompt2_response",
                "name": "prompt2_text",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt 3",
                "hidden": null,
                "method": "prompt3_response",
                "name": "prompt3_text",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt 4",
                "hidden": null,
                "method": "prompt4_response",
                "name": "prompt4_text",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt 5",
                "hidden": null,
                "method": "prompt5_response",
                "name": "prompt5_text",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt 6",
                "hidden": null,
                "method": "prompt6_response",
                "name": "prompt6_text",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, BoolInput, Output\nfrom langflow.schema.message import Message\nimport datetime\nimport re\n\nclass MultiPromptComponent(TextComponent):\n    display_name = \"Multi Prompt Input\"\n    description = \"Gerencia múltiplos prompts com saídas unificadas e individuais.\"\n    icon = \"message-square-text\"\n    name = \"MultiPromptInput\"\n    \n    inputs = [\n        # Prompt 1\n        MultilineInput(\n            name=\"prompt1\",\n            display_name=\"Prompt 1\",\n            info=\"Texto do primeiro prompt.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"dynamic_prompt1\",\n            display_name=\"Prompt Dinâmico 1\",\n            info=\"Se o primeiro prompt deve ser tratado como dinâmico.\",\n            value=False,\n        ),\n        \n        # Prompt 2\n        MultilineInput(\n            name=\"prompt2\",\n            display_name=\"Prompt 2\",\n            info=\"Texto do segundo prompt.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"dynamic_prompt2\",\n            display_name=\"Prompt Dinâmico 2\",\n            info=\"Se o segundo prompt deve ser tratado como dinâmico.\",\n            value=False,\n        ),\n        \n        # Prompt 3\n        MultilineInput(\n            name=\"prompt3\",\n            display_name=\"Prompt 3\",\n            info=\"Texto do terceiro prompt.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"dynamic_prompt3\",\n            display_name=\"Prompt Dinâmico 3\",\n            info=\"Se o terceiro prompt deve ser tratado como dinâmico.\",\n            value=False,\n        ),\n        \n        # Prompt 4\n        MultilineInput(\n            name=\"prompt4\",\n            display_name=\"Prompt 4\",\n            info=\"Texto do quarto prompt.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"dynamic_prompt4\",\n            display_name=\"Prompt Dinâmico 4\",\n            info=\"Se o quarto prompt deve ser tratado como dinâmico.\",\n            value=False,\n        ),\n        \n        # Prompt 5\n        MultilineInput(\n            name=\"prompt5\",\n            display_name=\"Prompt 5\",\n            info=\"Texto do quinto prompt.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"dynamic_prompt5\",\n            display_name=\"Prompt Dinâmico 5\",\n            info=\"Se o quinto prompt deve ser tratado como dinâmico.\",\n            value=False,\n        ),\n        \n        # Prompt 6\n        MultilineInput(\n            name=\"prompt6\",\n            display_name=\"Prompt 6\",\n            info=\"Texto do sexto prompt.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"dynamic_prompt6\",\n            display_name=\"Prompt Dinâmico 6\",\n            info=\"Se o sexto prompt deve ser tratado como dinâmico.\",\n            value=False,\n        ),\n        \n        # Separador global para saída unificada\n        MultilineInput(\n            name=\"separator\",\n            display_name=\"Separador\",\n            info=\"Texto a ser usado como separador entre prompts na saída unificada.\",\n            value=\"\\n\\n\",\n        ),\n    ]\n    \n    outputs = [\n        # Saída unificada\n        Output(display_name=\"Mensagem Unificada\", name=\"unified_text\", method=\"unified_response\"),\n        \n        # Saídas individuais\n        Output(display_name=\"Prompt 1\", name=\"prompt1_text\", method=\"prompt1_response\"),\n        Output(display_name=\"Prompt 2\", name=\"prompt2_text\", method=\"prompt2_response\"),\n        Output(display_name=\"Prompt 3\", name=\"prompt3_text\", method=\"prompt3_response\"),\n        Output(display_name=\"Prompt 4\", name=\"prompt4_text\", method=\"prompt4_response\"),\n        Output(display_name=\"Prompt 5\", name=\"prompt5_text\", method=\"prompt5_response\"),\n        Output(display_name=\"Prompt 6\", name=\"prompt6_text\", method=\"prompt6_response\"),\n    ]\n    \n    def _process_dynamic_prompt(self, prompt_text):\n        \"\"\"Processa um prompt dinâmico com substituições de variáveis.\"\"\"\n        if not prompt_text:\n            return \"\"\n        \n        # Substituições padrão de data/hora\n        replacements = {\n            \"{date}\": datetime.datetime.now().strftime(\"%Y-%m-%d\"),\n            \"{time}\": datetime.datetime.now().strftime(\"%H:%M:%S\"),\n            \"{datetime}\": datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"{year}\": datetime.datetime.now().strftime(\"%Y\"),\n            \"{month}\": datetime.datetime.now().strftime(\"%m\"),\n            \"{day}\": datetime.datetime.now().strftime(\"%d\"),\n        }\n        \n        # Aplicar substituições padrão\n        for key, value in replacements.items():\n            prompt_text = prompt_text.replace(key, value)\n        \n        # Procurar por variáveis customizadas no formato: {var:valor_padrao}\n        custom_vars = re.findall(r'\\{([^{}:]+):([^{}]+)\\}', prompt_text)\n        for var_name, default_value in custom_vars:\n            placeholder = f\"{{{var_name}:{default_value}}}\"\n            prompt_text = prompt_text.replace(placeholder, default_value)\n        \n        return prompt_text\n    \n    def _process_prompt(self, prompt_text, is_dynamic):\n        \"\"\"Processa um prompt com base em se é dinâmico ou estático.\"\"\"\n        if not prompt_text:\n            return \"\"\n        \n        if is_dynamic:\n            return self._process_dynamic_prompt(prompt_text)\n        \n        return prompt_text\n    \n    def unified_response(self) -> Message:\n        \"\"\"Retorna todos os prompts não vazios unidos com o separador.\"\"\"\n        prompts = []\n        \n        # Processa cada prompt se existir\n        for i in range(1, 7):\n            prompt_attr = f\"prompt{i}\"\n            dynamic_attr = f\"dynamic_prompt{i}\"\n            \n            if hasattr(self, prompt_attr) and getattr(self, prompt_attr):\n                is_dynamic = getattr(self, dynamic_attr, False)\n                processed_prompt = self._process_prompt(getattr(self, prompt_attr), is_dynamic)\n                if processed_prompt:\n                    prompts.append(processed_prompt)\n        \n        # Unir com separador\n        separator = self.separator if hasattr(self, \"separator\") else \"\\n\\n\"\n        unified_text = separator.join(prompts)\n        \n        return Message(text=unified_text)\n    \n    # Métodos de resposta individual\n    def prompt1_response(self) -> Message:\n        is_dynamic = getattr(self, \"dynamic_prompt1\", False)\n        processed = self._process_prompt(getattr(self, \"prompt1\", \"\"), is_dynamic)\n        return Message(text=processed)\n    \n    def prompt2_response(self) -> Message:\n        is_dynamic = getattr(self, \"dynamic_prompt2\", False)\n        processed = self._process_prompt(getattr(self, \"prompt2\", \"\"), is_dynamic)\n        return Message(text=processed)\n    \n    def prompt3_response(self) -> Message:\n        is_dynamic = getattr(self, \"dynamic_prompt3\", False)\n        processed = self._process_prompt(getattr(self, \"prompt3\", \"\"), is_dynamic)\n        return Message(text=processed)\n    \n    def prompt4_response(self) -> Message:\n        is_dynamic = getattr(self, \"dynamic_prompt4\", False)\n        processed = self._process_prompt(getattr(self, \"prompt4\", \"\"), is_dynamic)\n        return Message(text=processed)\n    \n    def prompt5_response(self) -> Message:\n        is_dynamic = getattr(self, \"dynamic_prompt5\", False)\n        processed = self._process_prompt(getattr(self, \"prompt5\", \"\"), is_dynamic)\n        return Message(text=processed)\n    \n    def prompt6_response(self) -> Message:\n        is_dynamic = getattr(self, \"dynamic_prompt6\", False)\n        processed = self._process_prompt(getattr(self, \"prompt6\", \"\"), is_dynamic)\n        return Message(text=processed)"
              },
              "dynamic_prompt1": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Prompt Dinâmico 1",
                "dynamic": false,
                "info": "Se o primeiro prompt deve ser tratado como dinâmico.",
                "list": false,
                "list_add_label": "Add More",
                "name": "dynamic_prompt1",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "dynamic_prompt2": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Prompt Dinâmico 2",
                "dynamic": false,
                "info": "Se o segundo prompt deve ser tratado como dinâmico.",
                "list": false,
                "list_add_label": "Add More",
                "name": "dynamic_prompt2",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "dynamic_prompt3": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Prompt Dinâmico 3",
                "dynamic": false,
                "info": "Se o terceiro prompt deve ser tratado como dinâmico.",
                "list": false,
                "list_add_label": "Add More",
                "name": "dynamic_prompt3",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "dynamic_prompt4": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Prompt Dinâmico 4",
                "dynamic": false,
                "info": "Se o quarto prompt deve ser tratado como dinâmico.",
                "list": false,
                "list_add_label": "Add More",
                "name": "dynamic_prompt4",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "dynamic_prompt5": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Prompt Dinâmico 5",
                "dynamic": false,
                "info": "Se o quinto prompt deve ser tratado como dinâmico.",
                "list": false,
                "list_add_label": "Add More",
                "name": "dynamic_prompt5",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "dynamic_prompt6": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Prompt Dinâmico 6",
                "dynamic": false,
                "info": "Se o sexto prompt deve ser tratado como dinâmico.",
                "list": false,
                "list_add_label": "Add More",
                "name": "dynamic_prompt6",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "prompt1": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Prompt 1",
                "dynamic": false,
                "info": "Texto do primeiro prompt.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "prompt1",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "TAREFA: Determinar se vídeos são EXTREMAMENTE relevantes para o produto/serviço descrito.  REGRAS ESTRITAS DE AVALIAÇÃO: 1. O vídeo DEVE abordar EXATAMENTE o mesmo nicho/função descrito na seção \"Nome do produto ou serviço\" abaixo 2. O conteúdo DEVE ser direcionado ao MESMO público-alvo identificado na descrição do produto/serviço 3. O vídeo DEVE discutir os MESMOS problemas específicos que o produto/serviço resolve 4. APENAS considere relevante se mencionar o produto/serviço seria NATURAL e ESPERADO  CRITÉRIOS DE EXCLUSÃO AUTOMÁTICA: - Vídeos sobre tecnologias ou métodos similares mas com propósito diferente - Vídeos direcionados a um público diferente do público-alvo do produto/serviço - Vídeos com apenas menções superficiais ao tema central do produto/serviço - Vídeos em que mencionar o produto/serviço pareceria forçado ou fora de contexto  INSTRUÇÕES DE ANÁLISE: 1. Leia CUIDADOSAMENTE a descrição completa do produto/serviço 2. Identifique o PROPÓSITO EXATO, PÚBLICO-ALVO e PROBLEMAS RESOLVIDOS 3. Compare cada vídeo com esses elementos específicos 4. Rejeite vídeos que não atendam a TODOS os critérios  RESPOSTA OBRIGATÓRIA: - Se NENHUM vídeo atender a TODOS os critérios: \"NOT\" - Se algum vídeo atender: apenas o ID (ex: \"abc123\" ou \"abc123,xyz789\")  QUALQUER EXPLICAÇÃO OU TEXTO ADICIONAL RESULTARÁ EM FALHA NA TAREFA.  Nome do produto ou serviço: ["
              },
              "prompt2": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Prompt 2",
                "dynamic": false,
                "info": "Texto do segundo prompt.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "prompt2",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "prompt3": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Prompt 3",
                "dynamic": false,
                "info": "Texto do terceiro prompt.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "prompt3",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "]\n\n\nDecricao do produto ou servico ["
              },
              "prompt4": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Prompt 4",
                "dynamic": false,
                "info": "Texto do quarto prompt.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "prompt4",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "]\n\n\nJAMAIS ESQUECA DAS REGRAS SOMENTE ID DO VIDEO SEPARADO POR VIRGULA CASO TENHA MAIS DE UM OU NOT"
              },
              "prompt5": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Prompt 5",
                "dynamic": false,
                "info": "Texto do quinto prompt.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "prompt5",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "prompt6": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Prompt 6",
                "dynamic": false,
                "info": "Texto do sexto prompt.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "prompt6",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "separator": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Separador",
                "dynamic": false,
                "info": "Texto a ser usado como separador entre prompts na saída unificada.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "separator",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n\n"
              }
            },
            "tool_mode": false
          },
          "selected_output": "unified_text",
          "showNode": true,
          "type": "MultiPromptInput"
        },
        "dragging": false,
        "id": "MultiPromptInput-l3Sqa",
        "measured": {
          "height": 970,
          "width": 320
        },
        "position": {
          "x": 2073.017018057297,
          "y": -220.4014885177973
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "description": "Get chat inputs from the Playground.",
          "display_name": "Chat Input",
          "id": "ChatInput-aPhAl",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "https://docs.langflow.org/components-io#chat-input",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Chat Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-input\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Chat Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        background_color = self.background_color\n        text_color = self.text_color\n        icon = self.chat_icon\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n            properties={\n                \"background_color\": background_color,\n                \"text_color\": text_color,\n                \"icon\": icon,\n            },\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Input Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatInput"
        },
        "dragging": false,
        "id": "ChatInput-aPhAl",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 312.87063693766083,
          "y": 694.6849604368817
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-uTbYl",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "https://docs.langflow.org/components-io#chat-output",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([safe_convert(item, clean_data=self.clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-uTbYl",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 3384.0836567703177,
          "y": 31.57107701031464
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-K2u5R",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.5.0.post1",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "hidden": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Descricao_servico: {descricao_servico},\nNome : {nome_produto_servico}\nPais: {pais}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-K2u5R",
        "measured": {
          "height": 329,
          "width": 320
        },
        "position": {
          "x": 1488.89137525882,
          "y": 704.0466826791906
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": 189.78449748041464,
      "y": 304.8761435288112,
      "zoom": 0.2
    }
  },
  "description": "Montitora se o video e bom ",
  "endpoint_name": null,
  "id": "1a9ae10d-43a7-497a-9687-c6c71bdf2c62",
  "is_component": false,
  "last_tested_version": "1.5.0.post1",
  "name": "Monitoramento de canais PRO",
  "tags": [
    "openai",
    "astradb",
    "rag",
    "q-a"
  ]
}